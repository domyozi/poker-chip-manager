<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>POKER ‚Äî „ÉÅ„ÉÉ„ÉóÁÆ°ÁêÜ</title>
<meta name="theme-color" content="#1a3328">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&family=Playfair+Display:wght@400;600;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
<style>
/* ‚îÄ‚îÄ‚îÄ CSS Variables ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
:root {
  --felt: #1a3328;
  --felt-light: #224438;
  --felt-edge: #142a22;
  --gold: #d4af37;
  --gold-dim: #a08528;
  --gold-glow: rgba(212,175,55,0.35);
  --chip-white: #f0ece0;
  --chip-red: #c0392b;
  --chip-blue: #2980b9;
  --text-primary: #f0ece0;
  --text-secondary: rgba(240,236,224,0.55);
  --text-muted: rgba(240,236,224,0.3);
  --radius: 16px;
  --shadow: 0 8px 40px rgba(0,0,0,0.5);
}

/* ‚îÄ‚îÄ‚îÄ Reset & Base ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; }
body {
  font-family: 'Source Code Pro', monospace;
  background: #0f1a16;
  color: var(--text-primary);
  min-height: 100vh;
  overflow-x: hidden;
  -webkit-font-smoothing: antialiased;
}

/* Prevent double-tap zoom on buttons */
button, .room-btn, .action-btn, .winner-btn, .start-btn, .ready-btn {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

/* ‚îÄ‚îÄ‚îÄ Screens ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.screen {
  position: fixed; inset: 0;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  background: #0d1412;
  z-index: 100;
  padding: 32px 20px 80px;
  transition: opacity 0.4s ease, transform 0.4s ease;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  overflow-anchor: none;
}
.screen:not(#game-screen) {
  background-image: url('img/backgroundimg.jpg');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}
.screen:not(#game-screen)::before {
  content: "";
  position: fixed;
  inset: 0;
  background: rgba(10, 14, 12, 0.7);
  z-index: 0;
  pointer-events: none;
}
.screen:not(#game-screen) > * {
  position: relative;
  z-index: 1;
}
.screen.screen-scroll-start,
#settings-screen,
#waiting-screen {
  justify-content: flex-start;
  padding-top: calc(32px + env(safe-area-inset-top));
}
.screen.hidden { opacity: 0; transform: scale(0.96); pointer-events: none; }
.screen { pointer-events: auto; }

.setup-title {
  font-family: 'Playfair Display', serif;
  font-size: 48px; font-weight: 700;
  color: var(--gold);
  letter-spacing: 6px;
  text-transform: uppercase;
  margin-bottom: 12px;
  text-shadow: 0 0 40px var(--gold-glow);
}
.brand-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
}
.brand-logo {
  width: 60px;
  height: 60px;
  object-fit: contain;
  filter: drop-shadow(0 0 12px rgba(0,0,0,0.4));
}
.brand-title {
  font-family: 'Cinzel', serif;
  font-size: 42px;
  font-weight: 700;
  color: var(--gold);
  letter-spacing: 3px;
  text-shadow: 0 0 40px var(--gold-glow);
}
.setup-subtitle {
  color: var(--text-primary);
  font-size: 14px;
  letter-spacing: 3px;
  text-transform: uppercase;
  margin-bottom: 40px;
  opacity: 0.8;
}

.setup-section { width: 100%; max-width: 400px; margin-bottom: 28px; }
.setup-label {
  font-size: 13px; font-weight: 600;
  letter-spacing: 2.5px; text-transform: uppercase;
  color: var(--gold);
  margin-bottom: 12px;
}
summary.setup-label {
  list-style: none;
  cursor: pointer;
}
summary.setup-label::-webkit-details-marker { display: none; }

/* Player input rows */
.player-inputs { display: flex; flex-direction: column; gap: 8px; }
.player-row {
  display: flex; align-items: center; gap: 10px;
}
.icon-picker {
  display: flex; gap: 6px;
  flex: 0 0 auto;
}
.icon-btn {
  width: 28px; height: 28px;
  border-radius: 50%;
  border: 1px solid rgba(255,255,255,0.15);
  background: rgba(255,255,255,0.06);
  display: flex; align-items: center; justify-content: center;
  font-size: 16px;
  cursor: pointer;
  transition: transform 0.12s, border-color 0.2s, background 0.2s;
}
.icon-btn:hover { border-color: rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); }
.icon-btn.selected {
  border-color: var(--gold);
  box-shadow: 0 0 10px var(--gold-glow);
  background: rgba(212,175,55,0.12);
}
.player-row input {
  flex: 1;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 10px;
  color: var(--chip-white);
  font-family: 'Playfair Display', serif;
  font-size: 15px; font-weight: 600;
  padding: 11px 14px;
  outline: none;
  transition: border-color 0.2s, box-shadow 0.2s;
}
.player-row input:focus {
  border-color: var(--gold-dim);
  box-shadow: 0 0 12px var(--gold-glow);
}
.player-row input::placeholder { color: var(--text-muted); }
.remove-btn {
  width: 28px; height: 28px;
  border-radius: 50%;
  background: rgba(192,57,43,0.15);
  border: 1px solid rgba(192,57,43,0.25);
  color: var(--chip-red);
  font-size: 16px; line-height: 28px;
  text-align: center;
  cursor: pointer;
  transition: background 0.2s;
  flex-shrink: 0;
}
.remove-btn:hover { background: rgba(192,57,43,0.3); }

.add-player-btn {
  width: 100%;
  padding: 10px;
  border-radius: 10px;
  background: rgba(255,255,255,0.04);
  border: 1px dashed rgba(255,255,255,0.15);
  color: var(--text-secondary);
  font-family: 'Source Code Pro', monospace;
  font-size: 12px; letter-spacing: 1px;
  cursor: pointer;
  transition: background 0.2s, color 0.2s;
  margin-top: 4px;
}
.add-player-btn:hover { background: rgba(255,255,255,0.08); color: var(--text-primary); }

/* Room controls */
.room-panel {
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding: 14px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.35);
  backdrop-filter: blur(6px);
}
.room-row { display: flex; gap: 8px; align-items: center; }
.room-input {
  flex: 1;
  background: rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.18);
  border-radius: 10px;
  color: var(--chip-white);
  font-family: 'Source Code Pro', monospace;
  font-size: 14px; font-weight: 600;
  padding: 10px 12px;
  outline: none;
  text-transform: uppercase;
  letter-spacing: 2px;
  pointer-events: auto;
}

.app-version {
  position: fixed;
  top: 10px; right: 14px;
  font-size: 11px;
  color: var(--text-muted);
  letter-spacing: 1px;
  z-index: 101;
}
.room-btn {
  padding: 12px 16px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(0,0,0,0.32);
  color: var(--text-primary);
  font-family: 'Source Code Pro', monospace;
  font-size: 12px; letter-spacing: 0.5px;
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s, transform 0.1s;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.room-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.2); }
.room-btn:active { transform: scale(0.97); }
.room-btn.primary {
  background: rgba(212,175,55,0.18);
  border-color: var(--gold-dim);
  color: var(--gold);
  font-size: 13px;
  font-weight: 600;
}
.room-status {
  font-size: 13px;
  color: var(--text-secondary);
  letter-spacing: 1px;
  margin-top: 8px;
}
.room-code-display {
  flex: 1;
  font-family: 'Playfair Display', serif;
  font-size: 22px;
  font-weight: 700;
  letter-spacing: 6px;
  color: var(--gold);
}
.participant-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.participant-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 10px;
  padding: 10px 12px;
  font-size: 12px;
  transition: all 0.3s ease;
}
.participant-item.self {
  background: rgba(212,175,55,0.15);
  border-color: var(--gold);
  box-shadow: 0 0 12px var(--gold-glow);
}
.participant-item.self .participant-name {
  color: var(--gold);
  font-weight: 700;
}
.participant-item.self::before {
  content: 'üë§';
  margin-right: 8px;
}
.participant-name {
  font-weight: 600;
  color: var(--chip-white);
  font-size: 14px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 180px;
}
.participant-meta { font-size: 11px; color: var(--text-secondary); letter-spacing: 1px; margin-top: 2px; }
.participant-role {
  padding: 2px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.1);
  font-size: 9px;
  letter-spacing: 1px;
  text-transform: uppercase;
}
.participant-role.host { color: var(--gold); border-color: var(--gold-dim); }
.participant-role.player { color: var(--text-secondary); }
.participant-role.offline { color: var(--text-muted); }
.participant-role.spectator { color: var(--text-muted); border-color: rgba(255,255,255,0.2); }
.participant-ready {
  font-size: 10px;
  letter-spacing: 1px;
  color: var(--text-muted);
}
.participant-ready.ready { color: #2ecc71; }
.waiting-self-panel {
  display: flex;
  gap: 10px;
  align-items: center;
  justify-content: space-between;
}
/* Step guide */
.step-guide {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  margin-bottom: 16px;
  padding: 10px 8px;
  background: rgba(255,255,255,0.03);
  border-radius: 12px;
  flex-wrap: wrap;
}
.step-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 10px;
  border-radius: 8px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
  transition: all 0.3s;
}
.step-item.active {
  background: rgba(212,175,55,0.15);
  border-color: var(--gold);
}
.step-item.done {
  background: rgba(46,204,113,0.15);
  border-color: #2ecc71;
}
.step-num {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--gold);
  color: #1a1408;
  font-size: 12px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
}
.step-item.done .step-num {
  background: #2ecc71;
}
.step-item.done .step-num::after {
  content: '‚úì';
}
.step-text {
  font-size: 11px;
  color: var(--text-secondary);
  letter-spacing: 0.5px;
  white-space: nowrap;
}
.step-item.active .step-text {
  color: var(--gold);
}
.step-item.done .step-text {
  color: #2ecc71;
}
.step-arrow {
  color: var(--text-muted);
  font-size: 16px;
}

/* Waiting indicator for guest */
.waiting-indicator {
  text-align: center;
  padding: 40px 20px;
}
.waiting-spinner {
  width: 48px;
  height: 48px;
  border: 3px solid rgba(212,175,55,0.2);
  border-top-color: var(--gold);
  border-radius: 50%;
  margin: 0 auto 20px;
  animation: spin 1s linear infinite;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}
.waiting-text {
  font-family: 'Playfair Display', serif;
  font-size: 18px;
  font-weight: 600;
  color: var(--gold);
  margin-bottom: 8px;
}
.screen-header {
  width: 100%;
  display: flex;
  align-items: center;
  gap: 8px;
  padding-top: env(safe-area-inset-top);
  margin-bottom: 8px;
}
.back-btn {
  position: static;
}
.waiting-subtext {
  font-size: 13px;
  color: var(--text-secondary);
  letter-spacing: 1px;
}

.seat-ring {
  position: relative;
  width: 100%;
  max-width: 260px;
  height: 200px;
  margin: 8px auto 14px;
  border-radius: 999px;
  background: radial-gradient(ellipse at center, rgba(26,51,40,0.9) 0%, rgba(20,42,34,0.7) 70%, transparent 100%);
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow: inset 0 0 24px rgba(0,0,0,0.4);
}
.seat-node {
  position: absolute;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'Playfair Display', serif;
  font-size: 12px;
  letter-spacing: 1px;
  color: var(--chip-white);
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.12);
  cursor: pointer;
  transition: transform 0.2s, border-color 0.2s, background 0.2s;
}
.seat-node:hover { transform: scale(1.05); border-color: rgba(212,175,55,0.5); }
.seat-node.taken { opacity: 0.4; cursor: not-allowed; }
.seat-node.active {
  background: rgba(212,175,55,0.2);
  border-color: var(--gold);
  color: var(--gold);
  box-shadow: 0 0 16px var(--gold-glow);
}
.seat-node .seat-label { font-size: 9px; color: var(--text-secondary); }
.seat-center {
  position: absolute;
  left: 50%; top: 50%;
  transform: translate(-50%, -50%);
  font-size: 10px;
  letter-spacing: 2px;
  color: var(--text-muted);
}
.ready-btn {
  padding: 12px 24px;
  border-radius: 999px;
  border: 2px solid var(--gold);
  background: rgba(212,175,55,0.15);
  color: var(--gold);
  font-family: 'Source Code Pro', monospace;
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 2px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  animation: ready-pulse 2s ease-in-out infinite;
}
.ready-btn::before {
  content: 'üëÜ TAP';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 10px;
  opacity: 0;
  animation: tap-hint 2s ease-in-out infinite;
}
.ready-btn:hover {
  background: rgba(212,175,55,0.25);
  box-shadow: 0 0 20px var(--gold-glow);
  transform: scale(1.05);
}
.ready-btn.on {
  background: rgba(46,204,113,0.25);
  border-color: #2ecc71;
  color: #2ecc71;
  animation: none;
  box-shadow: 0 0 16px rgba(46,204,113,0.4);
}
.ready-btn.on::before {
  display: none;
}
.ready-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  animation: none;
}
.ready-btn:disabled::before {
  display: none;
}

.per-player-stack-list {
  display: flex; flex-direction: column; gap: 8px;
  margin-top: 12px;
}
.stack-row {
  display: flex; align-items: center; gap: 8px;
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 12px;
  padding: 8px 10px;
}
.stack-name {
  font-size: 12px; color: var(--text-secondary);
  min-width: 80px;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.stack-input {
  width: 80px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 10px;
  color: var(--chip-white);
  padding: 6px 8px;
  font-family: 'Source Code Pro', monospace;
  font-size: 12px; font-weight: 600;
  text-align: right;
}
.stack-suffix {
  font-size: 11px; color: var(--text-muted);
}
.stack-meta {
  font-size: 10px;
  color: var(--text-muted);
  margin-left: auto;
}
@keyframes ready-pulse {
  0%, 100% { box-shadow: 0 0 8px var(--gold-glow); }
  50% { box-shadow: 0 0 24px var(--gold-glow), 0 0 48px rgba(212,175,55,0.2); }
}
@keyframes tap-hint {
  0%, 40%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
  50%, 90% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}
.player-badge {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 10px;
  letter-spacing: 1px;
  color: var(--text-secondary);
  margin-top: 6px;
}
.player-badge .tag {
  padding: 2px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.1);
  font-size: 9px;
  text-transform: uppercase;
}
.player-badge .tag.host { color: var(--gold); border-color: var(--gold-dim); }
.player-badge .tag.player { color: var(--text-secondary); }

/* Blind row */
.blind-row { display: flex; gap: 12px; }
.blind-input-wrap { flex: 1; }
.blind-input-label {
  display: block;
  font-size: 9px; letter-spacing: 2px;
  color: var(--text-muted);
  margin-bottom: 6px; text-transform: uppercase;
}
.blind-input-wrap input {
  width: 100%;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 10px;
  color: var(--gold);
  font-family: 'Source Code Pro', monospace;
  font-size: 18px; font-weight: 600;
  padding: 10px 14px;
  outline: none;
  transition: border-color 0.2s;
}
.blind-input-wrap input:focus { border-color: var(--gold-dim); }
.blind-input-wrap select {
  width: 100%;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 10px;
  color: var(--gold);
  font-family: 'Source Code Pro', monospace;
  font-size: 16px; font-weight: 600;
  padding: 10px 14px;
  outline: none;
  cursor: pointer;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23d4af37'%3E%3Cpath d='M6 8L1 3h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 12px center;
}
.blind-input-wrap select:focus { border-color: var(--gold-dim); }
.blind-input-wrap select option { background: #1a3328; color: var(--chip-white); }
.bb-hint {
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 6px;
}

/* Toggle label */
.toggle-label {
  display: flex; align-items: center; gap: 10px;
  cursor: pointer; padding: 8px 0;
}
.toggle-label input[type="checkbox"] {
  width: 18px; height: 18px;
  accent-color: var(--gold);
  cursor: pointer;
}
.toggle-text {
  font-size: 13px; color: var(--text-secondary);
  letter-spacing: 1px;
}
.tournament-toggle { margin-bottom: 8px; }
.tournament-options { padding-left: 28px; }

/* Timer progress ring */
.timer-ring {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
}
.timer-ring circle {
  fill: none;
  stroke-width: 3;
  stroke-linecap: round;
  transform: rotate(-90deg);
  transform-origin: center;
  transition: stroke-dashoffset 0.2s linear, stroke 0.3s;
}
.timer-ring .bg { stroke: rgba(255,255,255,0.1); }
.timer-ring .progress { stroke: var(--gold); }
.timer-ring .progress.warning { stroke: #f1c40f; }
.timer-ring .progress.danger { stroke: #e74c3c; }

/* Timer text display */
.timer-text {
  position: absolute;
  bottom: -24px; left: 50%;
  transform: translateX(-50%);
  font-size: 11px; font-weight: 600;
  color: var(--gold);
  font-family: 'Source Code Pro', monospace;
  white-space: nowrap;
}
.timer-text.warning { color: #f1c40f; }
.timer-text.danger { color: #e74c3c; animation: timer-blink 0.5s ease-in-out infinite; }
@keyframes timer-blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Tournament info bar */
.tournament-bar {
  position: fixed;
  top: 0; left: 0; right: 0;
  background: linear-gradient(180deg, rgba(26,51,40,0.95), rgba(26,51,40,0.8));
  padding: 8px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12px;
  z-index: 100;
  border-bottom: 1px solid rgba(212,175,55,0.2);
}
.tournament-bar .level { color: var(--gold); font-weight: 600; }
.tournament-bar .blinds { color: var(--text-secondary); }
.tournament-bar .next-level { color: var(--chip-white); }
.tournament-bar .next-level span { color: var(--gold); font-weight: 600; }

/* Start button */
.start-btn {
  width: 100%; max-width: 400px;
  padding: 18px;
  border-radius: 14px;
  background: linear-gradient(135deg, var(--gold), var(--gold-dim));
  border: none;
  color: #1a1408;
  font-family: 'Playfair Display', serif;
  font-size: 18px; font-weight: 700;
  letter-spacing: 3px; text-transform: uppercase;
  cursor: pointer;
  box-shadow: 0 4px 24px var(--gold-glow);
  transition: transform 0.15s, box-shadow 0.15s;
}
.start-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 32px var(--gold-glow); }
.start-btn:active { transform: translateY(0); }
.start-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; box-shadow: none; }

/* ‚îÄ‚îÄ‚îÄ Game Screen ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
#game-screen {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  background-image: url('img/backgroundplay.jpg');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  padding: 0;
}
#game-screen::before {
  content: "";
  position: fixed;
  inset: 0;
  background: rgba(10, 14, 12, 0.7);
  z-index: 0;
  pointer-events: none;
}
#game-screen > * {
  position: relative;
  z-index: 1;
}
#game-screen > .game-header {
  z-index: 50;
}

/* Header */
.game-header {
  display: flex; align-items: center; justify-content: center;
  padding: 10px 16px;
  background: var(--felt-edge);
  border-bottom: 1px solid rgba(255,255,255,0.06);
  position: relative;
  z-index: 50;
}
.game-header-brand {
  display: flex;
  align-items: center;
  gap: 8px;
}
.header-actions {
  position: absolute;
  right: 16px;
  top: 50%;
  transform: translateY(-50%);
}
.game-header-logo {
  width: 32px;
  height: 32px;
  object-fit: contain;
}
.game-header-title {
  font-family: 'Cinzel', serif;
  font-size: 18px;
  font-weight: 700;
  color: var(--gold);
  letter-spacing: 1px;
}
.game-header-version {
  font-size: 9px;
  color: var(--text-muted);
  margin-left: 6px;
}
.header-phase {
  display: none;
}
.header-phase-dot {
  display: none;
}
.header-actions { display: flex; gap: 8px; align-items: center; }
.header-btn {
  padding: 6px 14px;
  border-radius: 20px;
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.1);
  color: var(--text-secondary);
  font-family: 'Source Code Pro', monospace;
  font-size: 11px; letter-spacing: 1px;
  cursor: pointer;
  transition: background 0.2s, color 0.2s;
  pointer-events: auto;
  position: relative;
  z-index: 60;
}
.header-btn:hover { background: rgba(255,255,255,0.13); color: var(--text-primary); }
.header-menu {
  position: fixed;
  top: 52px; right: 12px;
  background: rgba(20,32,26,0.98);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 12px;
  padding: 6px;
  display: none;
  flex-direction: column;
  gap: 6px;
  z-index: 9999;
  min-width: 180px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}
.header-menu-item {
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.1);
  color: var(--text-primary);
  border-radius: 10px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 11px;
  letter-spacing: 1px;
  text-align: left;
  white-space: nowrap;
  writing-mode: horizontal-tb;
}
.header-menu-item:hover { background: rgba(255,255,255,0.12); }

/* Phase progress bar */
.phase-bar {
  display: flex; justify-content: center; gap: 0;
  background: var(--felt-edge);
  padding: 2px 0;
  border-bottom: 1px solid rgba(255,255,255,0.05);
  opacity: 1;
}
.phase-step {
  flex: 1; max-width: 80px;
  padding: 6px 0;
  text-align: center;
  font-size: 8px; font-weight: 600;
  letter-spacing: 1.2px; text-transform: uppercase;
  color: var(--text-muted);
  border-bottom: 1px solid transparent;
  transition: color 0.3s, border-color 0.3s;
  position: relative;
}
.phase-step.active {
  color: #121a15;
  border-bottom-color: transparent;
  text-shadow: none;
  background: linear-gradient(180deg, rgba(212,175,55,0.95), rgba(212,175,55,0.75));
  box-shadow: 0 8px 20px rgba(212,175,55,0.35);
  border-radius: 6px;
}
.phase-step.active::after {
  content: none;
}
.phase-step.completed { color: var(--text-secondary); border-bottom-color: rgba(255,255,255,0.15); }

/* ‚îÄ‚îÄ‚îÄ Table Area ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.table-area {
  flex: 1;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  padding: 24px 16px;
  background: radial-gradient(ellipse 80% 70% at 50% 50%, var(--felt) 0%, var(--felt-edge) 100%);
  position: relative;
  min-height: 340px;
}
.table-area::after {
  content: "";
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at 50% 50%, rgba(212,175,55,0.18), transparent 60%);
  opacity: 0;
  pointer-events: none;
}
.table-area.phase-pulse::after {
  animation: phase-pulse 0.6s ease-out;
}
@keyframes phase-pulse {
  0% { opacity: 0; transform: scale(0.98); }
  35% { opacity: 0.35; }
  100% { opacity: 0; transform: scale(1); }
}

/* Table felt oval */
.table-felt {
  position: absolute;
  width: 88%; max-width: 520px;
  height: 260px;
  border-radius: 130px;
  background: radial-gradient(ellipse at 50% 50%, var(--felt-light) 0%, var(--felt) 60%, #132a20 100%);
  border: 3px solid rgba(255,255,255,0.06);
  box-shadow: inset 0 0 60px rgba(0,0,0,0.4), 0 0 0 8px var(--felt-edge), 0 0 0 10px rgba(255,255,255,0.08);
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
}

/* Players ring */
.players-ring {
  position: relative;
  width: 100%; max-width: 480px;
  height: 320px;
  min-height: 320px;
  z-index: 2;
}

/* Player card ‚Äî positioned absolutely via JS */
.player-card {
  position: absolute;
  width: 110px;
  transform: translate(-50%, -50%);
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  transition: transform 0.3s cubic-bezier(.34,1.56,.64,1);
  cursor: default;
}
.player-card .avatar {
  width: 48px; height: 48px;
  border-radius: 50%;
  background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.03));
  border: 2px solid rgba(255,255,255,0.15);
  margin: 0 auto 6px;
  display: flex; align-items: center; justify-content: center;
  font-family: 'Playfair Display', serif;
  font-size: 18px; font-weight: 700;
  color: var(--text-secondary);
  transition: border-color 0.4s, box-shadow 0.4s, background 0.4s;
  position: relative;
}
.player-card.is-winner .avatar::after {
  content: "";
  position: absolute;
  inset: -6px;
  border-radius: 50%;
  border: 2px solid rgba(212,175,55,0.7);
  box-shadow: 0 0 18px rgba(212,175,55,0.45), 0 0 30px rgba(212,175,55,0.2);
  animation: winner-ring 1.4s ease-in-out infinite;
  pointer-events: none;
}
@keyframes winner-ring {
  0%, 100% { opacity: 0.25; transform: scale(0.98); }
  50% { opacity: 0.9; transform: scale(1.03); }
}
.player-card .info-line {
  display: flex;
  align-items: baseline;
  gap: 8px;
  margin-top: 4px;
  max-width: 100%;
  padding: 4px 8px;
  border-radius: 999px;
  background: rgba(12,20,16,0.55);
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow: 0 4px 12px rgba(0,0,0,0.35);
}
.player-card .name {
  font-family: 'Playfair Display', serif;
  font-size: 14px; font-weight: 700;
  color: var(--text-primary);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  max-width: 100px;
  transition: color 0.3s;
}
.player-card .name.is-empty { display: none; }
.player-card .chips {
  font-size: 11px; font-weight: 700;
  color: var(--gold);
  letter-spacing: 0.5px;
}
.player-card.seat-top .info-line {
  order: -1;
  margin-top: 0;
  margin-bottom: 8px;
  text-shadow: 0 2px 10px rgba(0,0,0,0.6);
}
.player-card .bet-badge {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(212,175,55,0.12);
  border: 1px solid var(--gold-dim);
  border-radius: 10px;
  padding: 2px 8px;
  font-size: 10px; font-weight: 600;
  color: var(--gold);
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.3s;
  pointer-events: none;
}

/* Active player glow */
.player-card.is-actor .avatar {
  border-color: var(--gold);
  box-shadow: 0 0 16px var(--gold-glow), 0 0 40px rgba(212,175,55,0.12);
  background: linear-gradient(135deg, rgba(212,175,55,0.12), rgba(212,175,55,0.03));
}
.player-card.is-actor .name { color: var(--gold); }
.player-card.is-actor { animation: actor-pulse 2s ease-in-out infinite; }
@keyframes actor-pulse {
  0%, 100% { filter: drop-shadow(0 0 0px transparent); }
  50% { filter: drop-shadow(0 0 12px rgba(212,175,55,0.25)); }
}

/* Dealer badge */
.dealer-badge {
  position: absolute;
  top: -4px; right: -4px;
  width: 18px; height: 18px;
  border-radius: 50%;
  background: var(--gold);
  border: 2px solid var(--felt-edge);
  color: #1a1408;
  font-size: 9px; font-weight: 700;
  display: flex; align-items: center; justify-content: center;
  box-shadow: 0 2px 8px var(--gold-glow);
}

/* Folded state */
.player-card.folded .avatar { opacity: 0.3; border-color: rgba(255,255,255,0.08); }
.player-card.folded .name { opacity: 0.3; }
.player-card.folded .chips { opacity: 0.3; }

/* AllIn badge */
.allin-badge {
  display: none;
  position: absolute; top: -8px; left: 50%;
  transform: translateX(-50%);
  background: var(--chip-red);
  color: #fff;
  font-size: 8px; font-weight: 600;
  letter-spacing: 1.5px; text-transform: uppercase;
  padding: 2px 7px; border-radius: 6px;
}
.player-card.allin .allin-badge { display: block; }
.player-card.allin .avatar { border-color: var(--chip-red); box-shadow: 0 0 10px rgba(192,57,43,0.3); }

/* ‚îÄ‚îÄ‚îÄ Pot Center ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.pot-center {
  position: absolute;
  top: calc(50% + 48px); left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  text-align: center;
  z-index: 3;
  pointer-events: none;
  padding: 8px 14px;
  border-radius: 16px;
  background: rgba(12,20,16,0.55);
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow: 0 6px 18px rgba(0,0,0,0.35);
}
.pot-label {
  font-size: 9px; font-weight: 700;
  letter-spacing: 2px; text-transform: uppercase;
  color: var(--text-muted);
  margin-bottom: 0;
}
.pot-amount {
  font-family: 'Playfair Display', serif;
  font-size: 28px; font-weight: 700;
  color: var(--gold);
  text-shadow: 0 0 20px var(--gold-glow);
  transition: transform 0.3s cubic-bezier(.34,1.56,.64,1);
}
.pot-amount.bump { animation: pot-bump 0.35s cubic-bezier(.34,1.56,.64,1); }
@keyframes pot-bump {
  0% { transform: scale(1); }
  50% { transform: scale(1.18); }
  100% { transform: scale(1); }
}
.pot-flyer {
  position: fixed;
  width: 18px; height: 18px;
  border-radius: 50%;
  background: radial-gradient(circle at 30% 30%, #fff1b8, var(--gold));
  box-shadow: 0 0 14px rgba(212,175,55,0.55), 0 4px 10px rgba(0,0,0,0.3);
  pointer-events: none;
  z-index: 132;
  transition: transform 0.65s cubic-bezier(.2,.8,.2,1), opacity 0.65s ease;
}

/* ‚îÄ‚îÄ‚îÄ Community Cards ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.community-cards {
  position: absolute;
  top: 49%; left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: clamp(8px, 1.6vw, 14px);
  margin: 0;
  z-index: 3;
  filter: drop-shadow(0 10px 18px rgba(0,0,0,0.28));
  perspective: 900px;
}
.community-slot {
  width: clamp(44px, 7vw, 76px);
  aspect-ratio: 2.5 / 3.5;
  border-radius: 12px;
  overflow: hidden;
  padding: 0;
  position: relative;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.18);
  box-shadow: 0 10px 22px rgba(0,0,0,0.28), 0 0 0 1px rgba(255,255,255,0.06);
  transform-style: preserve-3d;
}
.community-slot img {
  width: 100%;
  height: 103%;
  display: block;
  object-fit: cover;
  object-position: center;
  transform: translateY(-1.5%);
  filter: saturate(1.05) contrast(1.05);
  backface-visibility: hidden;
}
.community-slot.revealed img {
  animation: card-flip 0.45s ease-out;
}
.community-slot.revealed::after {
  content: "";
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at 50% 50%, rgba(212,175,55,0.3), transparent 60%);
  opacity: 0;
  animation: card-glow 0.45s ease-out;
  pointer-events: none;
}
@keyframes card-flip {
  0% { transform: translateY(-1.5%) rotateY(90deg) scale(0.96); filter: brightness(0.7); }
  60% { transform: translateY(-1.5%) rotateY(-6deg) scale(1.02); filter: brightness(1.1); }
  100% { transform: translateY(-1.5%) rotateY(0deg) scale(1); filter: brightness(1); }
}
@keyframes card-glow {
  0% { opacity: 0; }
  40% { opacity: 0.35; }
  100% { opacity: 0; }
}
.community-slot.empty {
  background: rgba(255,255,255,0.03);
  border: 1px dashed rgba(255,255,255,0.22);
  box-shadow: none;
  opacity: 0.55;
}

/* ‚îÄ‚îÄ‚îÄ Action Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.action-panel {
  background: var(--felt-edge);
  border-top: 1px solid rgba(255,255,255,0.06);
  padding: 16px 20px 24px;
  transition: opacity 0.3s;
}
.action-panel.hidden { opacity: 0; pointer-events: none; }
.action-panel.locked { opacity: 0.6; }
.action-panel.locked .action-btns,
.action-panel.locked .raise-area { display: none; }
.action-lock-message {
  text-align: center;
  font-size: 11px;
  color: var(--text-secondary);
  letter-spacing: 1px;
  margin-bottom: 12px;
}

.action-actor-label {
  text-align: center;
  font-size: 13px; font-weight: 600;
  color: var(--text-secondary);
  letter-spacing: 1px;
  margin-bottom: 16px;
}
.action-actor-label strong { color: var(--gold); font-family: 'Playfair Display', serif; font-size: 16px; }
.action-aux {
  display: none;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  margin: -4px 0 14px;
}
.aux-toggle {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 12px;
  color: var(--text-secondary);
  letter-spacing: 0.5px;
}
.aux-toggle input { display: none; }
.aux-toggle-track {
  width: 36px;
  height: 18px;
  border-radius: 999px;
  background: rgba(255,255,255,0.12);
  position: relative;
  transition: background 0.2s ease;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.2);
}
.aux-toggle-track::after {
  content: "";
  position: absolute;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #fff;
  top: 2px;
  left: 2px;
  transition: transform 0.2s ease;
}
.aux-toggle input:checked + .aux-toggle-track {
  background: rgba(214,64,69,0.5);
  box-shadow: inset 0 0 0 1px rgba(214,64,69,0.6);
}
.aux-toggle input:checked + .aux-toggle-track::after { transform: translateX(18px); }
.aux-exit-btn {
  border: 1px solid rgba(255,255,255,0.2);
  background: rgba(255,255,255,0.05);
  color: var(--text-secondary);
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 11px;
  letter-spacing: 0.5px;
  transition: 0.2s ease;
}
.aux-exit-btn:hover {
  color: var(--text-primary);
  border-color: rgba(255,255,255,0.4);
}
.aux-exit-btn.pending {
  border-color: rgba(214,64,69,0.7);
  color: #f0b0b0;
  background: rgba(214,64,69,0.12);
}

/* Action buttons row */
.action-btns { display: flex; gap: 12px; justify-content: center; margin-bottom: 14px; }
.action-btn {
  flex: 1; max-width: 120px;
  padding: 16px 12px;
  min-height: 54px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.1);
  background: rgba(255,255,255,0.06);
  color: var(--text-primary);
  font-family: 'Source Code Pro', monospace;
  font-size: 14px; font-weight: 600;
  letter-spacing: 0.5px;
  cursor: pointer;
  transition: background 0.15s, transform 0.1s, box-shadow 0.15s, border-color 0.15s;
  display: flex; flex-direction: column; align-items: center; gap: 4px;
  box-shadow: 0 6px 14px rgba(0,0,0,0.25);
}
.action-btn .btn-sub {
  font-size: 11px; font-weight: 600;
  color: var(--text-secondary);
  letter-spacing: 0;
}
.action-btn:hover { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.2); }
.action-btn:active { transform: translateY(1px) scale(0.98); box-shadow: 0 3px 8px rgba(0,0,0,0.25); }

.action-btn.btn-fold { border-color: rgba(192,57,43,0.2); background: rgba(192,57,43,0.06); }
.action-btn.btn-fold:hover { background: rgba(192,57,43,0.12); border-color: rgba(192,57,43,0.35); }
.action-btn.btn-fold .btn-label { color: var(--chip-red); }
.action-btn.btn-fold .btn-sub { color: rgba(192,57,43,0.7); }

.action-btn.btn-call { border-color: rgba(46,204,113,0.45); background: rgba(46,204,113,0.12); }
.action-btn.btn-call:hover { background: rgba(46,204,113,0.2); border-color: rgba(46,204,113,0.6); }
.action-btn.btn-call .btn-label { color: #2ecc71; }
.action-btn.btn-call .btn-sub { color: #2ecc71; }

.action-btn.btn-check { border-color: rgba(46,204,113,0.25); }
.action-btn.btn-check:hover { background: rgba(46,204,113,0.12); border-color: rgba(46,204,113,0.4); }
.action-btn.btn-check .btn-label { color: #2ecc71; }
.action-btn.btn-check .btn-sub { color: #2ecc71; }

.action-btn.btn-raise { border-color: var(--gold); background: rgba(212,175,55,0.16); }
.action-btn.btn-raise:hover { background: rgba(212,175,55,0.26); border-color: var(--gold); }
.action-btn.btn-raise .btn-label { color: var(--gold); }
.action-btn.btn-raise .btn-sub { color: var(--gold); }

/* Raise slider area */
.raise-area {
  display: none;
  flex-direction: column;
  align-items: stretch;
  gap: 10px;
  padding: 0 4px;
  margin-top: 4px;
}
.raise-area.visible { display: flex; }
.raise-presets {
  display: flex; gap: 8px;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  padding-bottom: 2px;
  scrollbar-width: none;
}
.raise-presets::-webkit-scrollbar { display: none; }
.raise-preset-btn {
  border: 1px solid rgba(212,175,55,0.35);
  background: rgba(212,175,55,0.08);
  color: var(--gold);
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 11px; font-weight: 600;
  font-family: 'Source Code Pro', monospace;
  white-space: nowrap;
  cursor: pointer;
  transition: transform 0.12s, background 0.2s, border-color 0.2s;
}
.raise-preset-btn.is-multi {
  background: rgba(76,184,255,0.1);
  border-color: rgba(76,184,255,0.35);
  color: #78c6ff;
}
.raise-preset-btn.is-multi:hover { background: rgba(76,184,255,0.18); border-color: #78c6ff; }
.raise-preset-btn.is-multi.active { background: rgba(76,184,255,0.25); border-color: #78c6ff; color: #d6f1ff; }
.raise-preset-btn:hover { background: rgba(212,175,55,0.18); border-color: var(--gold); }
.raise-preset-btn:active { transform: scale(0.96); }
.raise-preset-btn.active {
  background: rgba(212,175,55,0.22);
  border-color: var(--gold);
  color: #f6e3a8;
}
.raise-slider-row {
  display: flex; align-items: center; gap: 12px;
}
.raise-min {
  font-size: 11px;
  color: var(--text-muted);
  text-align: right;
  display: inline-block;
}
.raise-error {
  font-size: 11px;
  color: var(--chip-red);
  text-align: right;
}
.raise-area input[type=range] {
  flex: 1;
  -webkit-appearance: none;
  height: 4px;
  border-radius: 2px;
  background: linear-gradient(to right, rgba(255,255,255,0.1), var(--gold-dim));
  outline: none;
}
.raise-area input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 22px; height: 22px;
  border-radius: 50%;
  background: var(--gold);
  box-shadow: 0 2px 8px var(--gold-glow);
  cursor: pointer;
  transition: transform 0.1s;
}
.raise-area input[type=range]::-webkit-slider-thumb:active { transform: scale(1.15); }
.raise-amount {
  font-size: 14px; font-weight: 600;
  color: var(--gold);
  min-width: 52px; text-align: right;
  display: inline-block;
}
.value-bump { animation: value-bump 0.28s ease-out; }
@keyframes value-bump {
  0% { transform: scale(1); }
  50% { transform: scale(1.12); }
  100% { transform: scale(1); }
}

/* ‚îÄ‚îÄ‚îÄ Showdown / Winner Screen ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.showdown-overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.75);
  backdrop-filter: blur(4px);
  z-index: 140;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  padding: 24px;
  opacity: 0; pointer-events: none;
  transition: opacity 0.4s;
}
.showdown-overlay.visible { opacity: 1; pointer-events: auto; }

.showdown-card {
  background: var(--felt-edge);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 20px;
  padding: 32px 28px;
  width: 100%; max-width: 380px;
  box-shadow: var(--shadow);
  text-align: center;
}
.showdown-title {
  font-family: 'Playfair Display', serif;
  font-size: 11px; font-weight: 600;
  letter-spacing: 3px; text-transform: uppercase;
  color: var(--text-muted);
  margin-bottom: 20px;
}
.showdown-pot {
  font-family: 'Playfair Display', serif;
  font-size: 36px; font-weight: 700;
  color: var(--gold);
  text-shadow: 0 0 24px var(--gold-glow);
  margin-bottom: 4px;
}
.showdown-pot-label { font-size: 10px; color: var(--text-muted); letter-spacing: 2px; margin-bottom: 24px; }

/* Winner select buttons */
.winner-select { display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px; }
.winner-btn {
  display: flex; align-items: center; gap: 12px;
  padding: 12px 16px;
  border-radius: 12px;
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.1);
  color: var(--text-primary);
  font-family: 'Source Code Pro', monospace;
  font-size: 13px;
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s, transform 0.1s;
  width: 100%; text-align: left;
}
.winner-btn:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.2); }
.winner-btn:active { transform: scale(0.97); }
.winner-btn.selected {
  background: rgba(212,175,55,0.12);
  border-color: var(--gold);
}
.winner-btn .w-avatar {
  width: 32px; height: 32px; border-radius: 50%;
  background: rgba(255,255,255,0.08);
  display: flex; align-items: center; justify-content: center;
  font-family: 'Playfair Display', serif;
  font-size: 14px; font-weight: 700;
  color: var(--text-secondary);
  flex-shrink: 0;
}
.winner-btn.selected .w-avatar { background: rgba(212,175,55,0.2); color: var(--gold); }
.winner-btn .w-name { font-weight: 600; }
.winner-btn .w-chips { font-size: 11px; color: var(--text-muted); margin-left: auto; }

/* Confirm / split toggle */
.split-toggle {
  display: flex; align-items: center; gap: 8px;
  justify-content: center;
  margin-bottom: 16px;
}
.split-label { font-size: 11px; color: var(--text-muted); }
.toggle-switch {
  width: 36px; height: 20px;
  border-radius: 10px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.15);
  position: relative; cursor: pointer;
  transition: background 0.2s;
}
.toggle-switch.on { background: rgba(212,175,55,0.25); border-color: var(--gold-dim); }
.toggle-switch::after {
  content: '';
  position: absolute; top: 2px; left: 2px;
  width: 14px; height: 14px;
  border-radius: 50%; background: var(--text-secondary);
  transition: transform 0.2s, background 0.2s;
}
.toggle-switch.on::after { transform: translateX(16px); background: var(--gold); }

.confirm-winner-btn {
  width: 100%;
  padding: 14px;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--gold), var(--gold-dim));
  border: none;
  color: #1a1408;
  font-family: 'Playfair Display', serif;
  font-size: 14px; font-weight: 700;
  letter-spacing: 2px; text-transform: uppercase;
  cursor: pointer;
  transition: transform 0.15s, opacity 0.2s;
}
.confirm-winner-btn:hover { transform: translateY(-1px); }
.confirm-winner-btn:active { transform: translateY(0); }
.confirm-winner-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }


/* ‚îÄ‚îÄ‚îÄ Next hand prompt ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.next-hand-overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 130;
  display: flex; align-items: center; justify-content: center;
  opacity: 0; pointer-events: none;
  transition: opacity 0.3s;
}
.next-hand-overlay.visible { opacity: 1; pointer-events: auto; }
.next-hand-card {
  background: var(--felt-edge);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 18px;
  padding: 28px 24px;
  text-align: center;
  width: 90%; max-width: 340px;
}
.next-hand-winners {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 12px;
  margin-bottom: 6px;
}
.next-hand-winner-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}
.next-hand-winner-avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: var(--felt-light);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  border: 2px solid var(--gold);
}
.next-hand-winner-name {
  font-family: 'Playfair Display', serif;
  font-size: 16px;
  font-weight: 700;
  color: var(--gold);
}
.next-hand-sub { font-size: 11px; color: var(--text-muted); margin-bottom: 22px; }
.next-hand-gain {
  font-size: 12px;
  color: var(--gold);
  margin-bottom: 12px;
}
.next-hand-chip-status {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 16px;
  padding: 10px;
  background: rgba(0,0,0,0.2);
  border-radius: 10px;
}
.next-hand-chip-row {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
}
.next-hand-chip-avatar {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--felt-light);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  flex-shrink: 0;
}
.next-hand-chip-name {
  flex: 1;
  text-align: left;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.next-hand-chip-amount {
  color: var(--text-secondary);
  font-family: 'Source Code Pro', monospace;
  min-width: 60px;
  text-align: right;
}
.next-hand-chip-change {
  min-width: 50px;
  text-align: right;
  font-family: 'Source Code Pro', monospace;
  font-size: 11px;
}
.next-hand-chip-change.positive { color: #4ade80; }
.next-hand-chip-change.negative { color: #f87171; }
.next-hand-chip-change.neutral { color: var(--text-muted); }
.next-hand-btn {
  width: 100%; padding: 12px;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--gold), var(--gold-dim));
  border: none;
  color: #1a1408;
  font-family: 'Playfair Display', serif;
  font-size: 14px; font-weight: 700;
  letter-spacing: 2px; text-transform: uppercase;
  cursor: pointer;
  transition: transform 0.15s;
}
.next-hand-btn:hover { transform: translateY(-1px); }
.next-hand-btn.secondary {
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  color: var(--text-primary);
}
.next-hand-buttons {
  display: flex;
  gap: 8px;
  width: 100%;
}
.next-hand-buttons .next-hand-btn {
  flex: 1;
}

/* ‚îÄ‚îÄ‚îÄ Chip Status Overlay ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.chip-status-overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.85);
  display: flex; align-items: center; justify-content: center;
  z-index: 140;
  opacity: 0; pointer-events: none;
  transition: opacity 0.3s;
}
.chip-status-overlay.visible { opacity: 1; pointer-events: auto; }
.chip-status-card {
  background: var(--felt-edge);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 18px;
  padding: 24px;
  width: 90%; max-width: 360px;
}
.chip-status-title {
  font-family: 'Playfair Display', serif;
  font-size: 18px; font-weight: 700;
  color: var(--gold);
  text-align: center;
  margin-bottom: 16px;
}
.chip-status-table {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 16px;
  max-height: 300px;
  overflow-y: auto;
}
.chip-status-row {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 10px;
  background: rgba(255,255,255,0.04);
  border-radius: 10px;
}
.chip-status-avatar {
  width: 32px; height: 32px;
  border-radius: 50%;
  background: var(--felt-light);
  display: flex; align-items: center; justify-content: center;
  font-size: 16px;
}
.chip-status-name {
  flex: 1;
  font-size: 13px;
  color: var(--text-primary);
}
.chip-status-chips {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}
.chip-status-change {
  font-size: 12px;
  min-width: 60px;
  text-align: right;
}
.chip-status-change.positive { color: #4ade80; }
.chip-status-change.negative { color: #f87171; }
.chip-status-change.neutral { color: var(--text-muted); }

/* ‚îÄ‚îÄ‚îÄ History List ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.history-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-height: 400px;
  overflow-y: auto;
  margin-bottom: 16px;
}
.history-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin: 10px 0 12px;
}
.history-filter {
  flex: 1 1 120px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.history-filter input {
  width: 100%;
  padding: 8px 10px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.2);
  background: rgba(255,255,255,0.06);
  color: var(--text-primary);
  font-family: 'Source Code Pro', monospace;
  font-size: 12px;
}
.history-filter input:focus {
  outline: none;
  border-color: var(--gold-dim);
}
.history-filter-actions {
  display: flex;
  gap: 8px;
  margin-top: 4px;
}
.history-filter-btn {
  padding: 8px 10px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.2);
  background: rgba(255,255,255,0.08);
  color: var(--text-primary);
  font-family: 'Source Code Pro', monospace;
  font-size: 11px;
  cursor: pointer;
}
.history-item {
  background: rgba(255,255,255,0.04);
  border-radius: 10px;
  padding: 10px 12px;
}
.history-header {
  font-size: 11px;
  color: var(--text-muted);
  margin-bottom: 6px;
}
.history-result {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  font-size: 12px;
}
.history-winner {
  color: #4ade80;
}
.history-loser {
  color: #f87171;
}
.history-empty {
  text-align: center;
  color: var(--text-muted);
  padding: 20px;
  font-size: 13px;
}

/* ‚îÄ‚îÄ‚îÄ Winner celebration flash ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.win-flash {
  position: fixed; inset: 0;
  background: radial-gradient(ellipse at center, rgba(212,175,55,0.15) 0%, transparent 70%);
  pointer-events: none; z-index: 44;
  opacity: 0; transition: opacity 0.3s;
}
.win-flash.visible { opacity: 1; }

/* ‚îÄ‚îÄ‚îÄ Debug Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
#debug-panel {
  position: fixed;
  bottom: 10px; right: 10px;
  max-width: 90vw;
  width: 300px;
  background: rgba(0,0,0,0.8);
  color: #fff;
  font-size: 11px;
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  z-index: 9999;
}
#debug-panel header {
  display: flex; justify-content: space-between; align-items: center;
  padding: 6px 8px;
  cursor: pointer;
  background: rgba(255,255,255,0.06);
}
#debug-panel .content {
  max-height: 160px;
  overflow: auto;
  padding: 6px 8px;
  font-family: 'Source Code Pro', monospace;
}
#debug-panel.collapsed .content { display: none; }

/* ‚îÄ‚îÄ‚îÄ Confirm Dialog ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.confirm-dialog-overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 150;
  display: flex; align-items: center; justify-content: center;
  opacity: 0; pointer-events: none;
  transition: opacity 0.3s;
}
.confirm-dialog-overlay.visible { opacity: 1; pointer-events: auto; }
.confirm-dialog {
  background: var(--felt-edge);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 16px;
  padding: 24px;
  width: 90%; max-width: 320px;
  text-align: center;
}
.confirm-dialog-title {
  font-family: 'Playfair Display', serif;
  font-size: 16px; font-weight: 600;
  color: var(--gold);
  margin-bottom: 12px;
}
.confirm-dialog-message {
  font-size: 14px;
  color: var(--text-secondary);
  margin-bottom: 20px;
  line-height: 1.5;
}
.confirm-dialog-buttons {
  display: flex; gap: 10px;
}
.confirm-dialog-btn {
  flex: 1;
  padding: 12px;
  border-radius: 10px;
  font-family: 'Source Code Pro', monospace;
  font-size: 13px; font-weight: 600;
  cursor: pointer;
  transition: background 0.2s, transform 0.1s;
}
.confirm-dialog-btn.cancel {
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.15);
  color: var(--text-primary);
}
.confirm-dialog-btn.cancel:hover { background: rgba(255,255,255,0.15); }
.confirm-dialog-btn.danger {
  background: rgba(192,57,43,0.2);
  border: 1px solid rgba(192,57,43,0.4);
  color: var(--chip-red);
}
.confirm-dialog-btn.danger:hover { background: rgba(192,57,43,0.35); }
.confirm-dialog-btn:active { transform: scale(0.97); }
.confirm-dialog-btn.primary {
  background: linear-gradient(135deg, var(--gold), var(--gold-dim));
  border: 1px solid rgba(212,175,55,0.8);
  color: #1a1408;
}
.confirm-dialog-btn.primary:hover {
  filter: brightness(1.05);
}

/* ‚îÄ‚îÄ‚îÄ Join Status Banner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.join-status-banner {
  display: none;
  margin: 10px 16px 0;
  padding: 10px 12px;
  border-radius: 12px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.12);
  font-size: 12px;
  color: var(--text-secondary);
  box-shadow: 0 8px 24px rgba(0,0,0,0.25);
}
.join-status-banner.visible { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
.join-status-left {
  display: flex;
  align-items: center;
  gap: 10px;
}
.join-status-badge {
  width: 28px;
  height: 28px;
  border-radius: 10px;
  background: rgba(212,175,55,0.15);
  border: 1px solid rgba(212,175,55,0.5);
  color: var(--gold);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  box-shadow: 0 0 10px rgba(212,175,55,0.2);
}
.join-status-text {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.join-status-title {
  font-size: 12px;
  color: var(--text-primary);
  font-weight: 700;
}
.join-status-sub {
  font-size: 11px;
  color: var(--text-secondary);
}
.join-status-actions { display: flex; gap: 8px; }
.join-progress {
  width: 100%;
  height: 6px;
  border-radius: 999px;
  background: rgba(255,255,255,0.08);
  overflow: hidden;
  margin-top: 6px;
}
.join-progress-bar {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, rgba(212,175,55,0.6), rgba(212,175,55,1));
  transition: width 0.2s;
}
.join-status-btn {
  padding: 6px 10px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.2);
  background: rgba(255,255,255,0.08);
  color: var(--text-primary);
  font-family: 'Source Code Pro', monospace;
  font-size: 11px;
  cursor: pointer;
}
.join-status-btn.danger {
  border-color: rgba(192,57,43,0.4);
  color: var(--chip-red);
}
.join-status-btn.danger:hover { background: rgba(192,57,43,0.12); }

/* ‚îÄ‚îÄ‚îÄ Seat Select Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.seat-select-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
  margin: 12px 0 6px;
}
.seat-select-btn {
  padding: 10px 0;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.15);
  background: rgba(255,255,255,0.08);
  color: var(--text-primary);
  font-family: 'Source Code Pro', monospace;
  font-size: 11px;
  cursor: pointer;
}
.seat-select-btn.taken {
  opacity: 0.45;
  cursor: not-allowed;
}
.seat-select-btn.active {
  border-color: var(--gold);
  background: rgba(212,175,55,0.15);
  color: var(--gold);
  box-shadow: 0 0 12px rgba(212,175,55,0.2);
}

/* ‚îÄ‚îÄ‚îÄ Toast ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.toast {
  position: fixed;
  left: 50%;
  bottom: 24px;
  transform: translateX(-50%);
  background: rgba(20,32,26,0.95);
  border: 1px solid rgba(212,175,55,0.4);
  color: var(--text-primary);
  padding: 10px 14px;
  border-radius: 12px;
  font-size: 12px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s, transform 0.2s;
  z-index: 200;
}
.toast.visible {
  opacity: 1;
  transform: translateX(-50%) translateY(-6px);
}
/* ‚îÄ‚îÄ‚îÄ Reconnect / Join Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.reconnect-dialog-body {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 6px;
}
.reconnect-dialog-note {
  font-size: 12px;
  color: var(--text-muted);
}
.reconnect-row {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  flex-wrap: wrap;
}
.reconnect-chip-input {
  width: 140px;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.2);
  background: rgba(255,255,255,0.06);
  color: var(--text-primary);
  font-family: 'Source Code Pro', monospace;
  font-size: 14px;
}
.reconnect-chip-input:focus {
  outline: none;
  border-color: var(--gold-dim);
}

/* ‚îÄ‚îÄ‚îÄ Responsive tweak ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
@media (max-width: 400px) {
  .brand-title { font-size: 28px; letter-spacing: 2px; }
  .brand-logo { width: 40px; height: 40px; }
  .player-card { width: 90px; }
  .player-card .avatar { width: 40px; height: 40px; font-size: 15px; }
  .player-card .name { font-size: 10px; }
  .player-card .chips { font-size: 11px; }
  .pot-amount { font-size: 24px; }
  .action-btns { gap: 6px; }
  .action-btn { max-width: 90px; padding: 11px 6px; font-size: 11px; }
}

@media (max-width: 520px) {
  .community-cards { gap: 10px; }
  .community-slot { border-radius: 10px; }
  .player-row { flex-direction: column; align-items: stretch; gap: 8px; }
  .icon-picker { width: 100%; overflow-x: auto; padding-bottom: 4px; }
  .icon-picker::-webkit-scrollbar { display: none; }
  .icon-btn { flex: 0 0 28px; }
  .remove-btn { align-self: flex-end; }
}

/* „Çπ„Éû„ÉõÊ®™Âêë„Åç */
@media (max-height: 500px) and (orientation: landscape) {
  .players-ring { height: 260px; min-height: 260px; }
  .player-card { width: 85px; }
  .player-card .avatar { width: 36px; height: 36px; font-size: 14px; }
  .player-card .name { font-size: 10px; }
  .player-card .chips { font-size: 10px; }
  .pot-center { transform: translate(-50%, -50%) scale(0.85); }
  .action-panel { padding: 10px 16px; }
  .action-btn { padding: 10px 8px; }
}
</style>
</head>
<body>

<!-- ‚îÄ‚îÄ‚îÄ ROOM SCREEN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="room-screen" class="screen">
  <div class="app-version" id="app-version">v0.0.0</div>
  <div class="brand-header">
    <img src="img/logo.png" alt="Pocket Pot" class="brand-logo">
    <div class="brand-title">Pocket Pot</div>
  </div>
  <div class="setup-section">
    <div class="setup-label">„ÅÇ„Å™„Åü„ÅÆÂêçÂâç</div>
    <div class="room-panel">
      <input type="text" id="display-name-input" class="room-input" placeholder="Ë°®Á§∫Âêç">
    </div>
  </div>

  <div class="setup-section">
    <div class="setup-label">„Ç™„É≥„É©„Ç§„É≥„ÅßÈÅä„Å∂</div>
    <div class="room-panel">
      <div class="room-row">
        <button class="room-btn primary" id="room-host-btn" style="flex:1;">üé≤ Êñ∞„Åó„ÅÑ„É´„Éº„É†‰ΩúÊàê</button>
      </div>
      <div class="room-row" style="margin-top:8px;">
        <input type="text" id="room-code-input" class="room-input" placeholder="„É´„Éº„É†„Ç≥„Éº„Éâ" maxlength="6" style="text-align:center;">
        <button class="room-btn" id="room-join-btn">ÂèÇÂä†</button>
      </div>
      <div class="room-status" id="room-status"></div>
    </div>
  </div>

  <div class="setup-section">
    <div class="setup-label">„Ç™„Éï„É©„Ç§„É≥„ÅßÈÅä„Å∂</div>
    <div class="room-panel">
      <button class="room-btn" id="room-local-btn" style="width:100%;">üì± 1Á´ØÊú´„ÅßÈñãÂßãÔºàË§áÊï∞‰∫∫„ÅßÁîªÈù¢„ÇíÂÖ±ÊúâÔºâ</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ WAITING SCREEN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="waiting-screen" class="screen hidden">
  <div class="screen-header">
    <button class="room-btn back-btn" id="waiting-back-btn">‚Üê Êàª„Çã</button>
  </div>
  <div class="brand-header">
    <img src="img/logo.png" alt="Pocket Pot" class="brand-logo">
    <div class="brand-title">Pocket Pot</div>
  </div>
  <div class="setup-subtitle">ÂèÇÂä†ËÄÖ„ÅåÊèÉ„ÅÜ„ÅÆ„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô</div>

  <div class="setup-section">
    <div class="setup-label">„É´„Éº„É†„Ç≥„Éº„Éâ</div>
    <div class="room-panel">
      <div class="room-row">
        <div class="room-code-display" id="room-code-display">‚Äî</div>
        <button class="room-btn" id="room-copy-btn">COPY</button>
      </div>
    </div>
  </div>

  <div class="setup-section">
    <div class="setup-label">ÂèÇÂä†ËÄÖ</div>
    <div class="room-panel">
      <div class="participant-list" id="participant-list"></div>
    </div>
  </div>

  <div class="setup-section">
    <div class="setup-label">„Ç≤„Éº„É†„ÇíÂßã„ÇÅ„ÇãÊ∫ñÂÇô</div>
    <div class="room-panel">
      <div class="step-guide">
        <div class="step-item" id="step-seat">
          <span class="step-num">1</span>
          <span class="step-text">„ÉÜ„Éº„Éñ„É´„ÅÆÁ©∫Â∏≠„Çí„Çø„ÉÉ„Éó</span>
        </div>
        <div class="step-item" id="step-ready">
          <span class="step-num">2</span>
          <span class="step-text">READY„Éú„Çø„É≥„ÇíÊäº„Åô</span>
        </div>
      </div>
      <div class="seat-ring" id="seat-ring"></div>
      <div class="waiting-self-panel">
        <div class="room-status" id="seat-help-text">üëÜ „Åæ„ÅöÁ©∫Â∏≠„Çí„Çø„ÉÉ„Éó„Åó„Å¶„Å≠</div>
        <button class="ready-btn" id="ready-toggle-btn" disabled>READY</button>
      </div>
    </div>
  </div>

  <div class="setup-section" id="waiting-host-controls" style="display:none;">
    <button class="start-btn" id="waiting-start-btn">Ë®≠ÂÆö„Å∏ÈÄ≤„ÇÄ</button>
    <div class="room-status" id="waiting-host-status">2‰∫∫‰ª•‰∏ä„ÅßÈñãÂßã„Åß„Åç„Åæ„Åô</div>
  </div>

  <div class="setup-section" id="waiting-guest-controls">
    <div class="room-panel">
      <div class="room-status">„Éõ„Çπ„Éà„ÅåÈñãÂßã„Åô„Çã„ÅÆ„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô</div>
      <button class="room-btn" id="room-leave-btn">ÈÄÄÂá∫</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ SETTINGS SCREEN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="settings-screen" class="screen hidden">
  <div class="screen-header">
    <button class="room-btn back-btn" id="settings-back-btn">‚Üê Êàª„Çã</button>
  </div>
  <div class="brand-header">
    <img src="img/logo.png" alt="Pocket Pot" class="brand-logo">
    <div class="brand-title">Pocket Pot</div>
  </div>
  <div class="setup-subtitle">„Ç≤„Éº„É†Ë®≠ÂÆö</div>

  <div id="settings-host-panel">
    <div class="setup-section">
      <div class="setup-label">Âü∫Êú¨Ë®≠ÂÆö</div>
      <div class="blind-row">
        <div class="blind-input-wrap">
          <span class="blind-input-label">Small Blind</span>
          <input type="number" id="sb-input" value="10" min="1" inputmode="numeric" pattern="[0-9]*" enterkeyhint="done">
        </div>
        <div class="blind-input-wrap">
          <span class="blind-input-label">Big Blind</span>
          <input type="number" id="bb-input" value="20" min="1" inputmode="numeric" pattern="[0-9]*" enterkeyhint="done">
        </div>
      </div>
      <div class="blind-row" id="initial-chips-row" style="margin-top: 12px;">
        <div class="blind-input-wrap" style="flex: 1;">
          <span class="blind-input-label">ÂàùÊúü„ÉÅ„ÉÉ„Éó</span>
          <input type="number" id="initial-chips-input" value="1000" min="1" inputmode="numeric" pattern="[0-9]*" enterkeyhint="done">
          <div class="bb-hint" id="initial-chips-bb">ÂàùÊúü„ÉÅ„ÉÉ„ÉóÔºö1000Ôºà= 50 BBÔºâ</div>
        </div>
      </div>
    <div class="blind-row" style="margin-top: 12px;">
      <label class="toggle-label" style="width:100%;">
        <input type="checkbox" id="per-player-stack-toggle">
        <span class="toggle-text">„Éó„É¨„Ç§„É§„ÉºÂà•„Å´ÂàùÊúü„ÉÅ„ÉÉ„Éó„ÇíË®≠ÂÆö</span>
      </label>
    </div>
    <div class="per-player-stack-list" id="per-player-stack-list" style="display:none;"></div>
  </div>

    <div class="setup-section" id="online-player-summary" style="display:none;">
      <div class="setup-label">ÂèÇÂä†ËÄÖ</div>
      <div class="room-panel">
        <div class="participant-list" id="participant-summary"></div>
      </div>
    </div>

    <div class="setup-section" id="local-player-settings">
      <div class="setup-label">„É≠„Éº„Ç´„É´ÂèÇÂä†ËÄÖ</div>
      <div class="player-inputs" id="player-inputs">
        <div class="player-row">
          <input type="text" class="player-name-input" placeholder="„Éó„É¨„Ç§„É§„ÉºÂêç" value="„Éó„É¨„Ç§„É§„ÉºÔºë">
          <div class="icon-picker"></div>
          <button class="remove-btn" onclick="removePlayer(this)">√ó</button>
        </div>
        <div class="player-row">
          <input type="text" class="player-name-input" placeholder="„Éó„É¨„Ç§„É§„ÉºÂêç" value="„Éó„É¨„Ç§„É§„ÉºÔºí">
          <div class="icon-picker"></div>
          <button class="remove-btn" onclick="removePlayer(this)">√ó</button>
        </div>
      </div>
      <button class="add-player-btn" onclick="addPlayer()">Ôºã „Éó„É¨„Ç§„É§„ÉºËøΩÂä†</button>
    </div>

    <details class="setup-section">
      <summary class="setup-label">Ë©≥Á¥∞Ë®≠ÂÆö</summary>
      <div class="blind-row" style="margin-top: 12px;">
        <div class="blind-input-wrap">
          <span class="blind-input-label">„Ç¢„ÇØ„Ç∑„Éß„É≥„Çø„Ç§„Éû„Éº</span>
          <select id="timer-select">
            <option value="0" selected>ÁÑ°Âà∂Èôê</option>
            <option value="15">15Áßí</option>
            <option value="30">30Áßí</option>
            <option value="60">60Áßí</option>
          </select>
        </div>
        <div class="blind-input-wrap">
          <label class="toggle-label">
            <input type="checkbox" id="timer-sound-toggle" checked>
            <span class="toggle-text">ÂäπÊûúÈü≥</span>
          </label>
        </div>
      </div>
      <label class="toggle-label tournament-toggle">
        <input type="checkbox" id="tournament-mode-toggle">
        <span class="toggle-text">„Éà„Éº„Éä„É°„É≥„Éà„É¢„Éº„Éâ</span>
      </label>
      <label class="toggle-label" style="margin-top: 10px;">
        <input type="checkbox" id="late-join-toggle" checked>
        <span class="toggle-text">ÈÄî‰∏≠ÂèÇÂä†„ÇíË®±ÂèØ</span>
      </label>
      <div class="blind-row" style="margin-top: 8px;">
        <div class="blind-input-wrap" style="flex: 1;">
          <span class="blind-input-label">ÈÄî‰∏≠ÂèÇÂä†„ÅÆÊúÄÂ§ß„Çπ„Çø„ÉÉ„ÇØ</span>
          <input type="number" id="late-join-max-chips" value="1000" min="1" inputmode="numeric" pattern="[0-9]*" enterkeyhint="done">
        </div>
      </div>
      <div class="tournament-options" id="tournament-options" style="display: none;">
        <div class="blind-row" style="margin-top: 12px;">
          <div class="blind-input-wrap" style="flex: 1;">
            <span class="blind-input-label">„Éñ„É©„Ç§„É≥„Éâ„É¨„Éô„É´ÊôÇÈñì</span>
            <select id="blind-level-select">
              <option value="10">10ÂàÜ</option>
              <option value="15" selected>15ÂàÜ</option>
              <option value="20">20ÂàÜ</option>
            </select>
          </div>
        </div>
      </div>
    </details>

    <button class="start-btn" id="start-btn">Á¢∫ÂÆö„Åó„Å¶ÈñãÂßã</button>
  </div>

  <div id="settings-guest-panel" style="display:none;">
    <div class="setup-section">
      <div class="waiting-indicator">
        <div class="waiting-spinner"></div>
        <div class="waiting-text">„Éõ„Çπ„Éà„Åå„Ç≤„Éº„É†Ë®≠ÂÆö‰∏≠...</div>
        <div class="waiting-subtext">„Åæ„ÇÇ„Å™„Åè„Ç≤„Éº„É†„ÅåÂßã„Åæ„Çä„Åæ„Åô</div>
      </div>
    </div>
    <div class="setup-section">
      <div class="room-panel">
        <div class="participant-list" id="guest-participant-summary"></div>
      </div>
    </div>
    <div class="setup-section">
      <button class="room-btn" id="settings-leave-btn" style="width:100%;">ÈÄÄÂá∫</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ GAME SCREEN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="game-screen" class="screen hidden">
  <div class="tournament-bar" id="tournament-bar" style="display: none;">
    <div class="level">Level 1</div>
    <div class="blinds">10 / 20</div>
    <div class="next-level">Ê¨°„ÅÆ„É¨„Éô„É´„Åæ„Åß: <span>15:00</span></div>
  </div>
  <div class="game-header">
    <div class="game-header-brand">
      <img src="img/logo.png" alt="Pocket Pot" class="game-header-logo">
      <span class="game-header-title">Pocket Pot</span>
      <span class="game-header-version">v0.6.0</span>
    </div>
    <div class="header-actions">
      <div class="player-badge" id="player-badge" style="display:none;">
        <span class="tag" id="player-role-tag">PLAYER</span>
        <span id="player-name-tag">‚Äî</span>
      </div>
      <button class="header-btn" id="menu-btn">‚ãØ</button>
    </div>
  </div>

  <div class="phase-bar" id="phase-bar">
    <div class="phase-step active" data-phase="preflop">PRE</div>
    <div class="phase-step" data-phase="flop">FLOP</div>
    <div class="phase-step" data-phase="turn">TURN</div>
    <div class="phase-step" data-phase="river">RIVER</div>
  </div>

  <div class="join-status-banner" id="join-status-banner">
    <div class="join-status-left">
      <div class="join-status-badge">‚è≥</div>
      <div class="join-status-text">
        <div class="join-status-title" id="join-status-title">ÂèÇÂä†ÂæÖÊ©ü‰∏≠</div>
        <div class="join-status-sub" id="join-status-sub">Â∏≠„ÇíÈÅ∏„Å∂„Å®Ê¨°„Éè„É≥„Éâ„Åã„ÇâÂèÇÂä†</div>
        <div class="join-progress">
          <div class="join-progress-bar" id="join-progress-bar"></div>
        </div>
      </div>
    </div>
    <div class="join-status-actions">
      <button class="join-status-btn" id="rebuy-request-btn" style="display:none;">„É™„Éê„Ç§Áî≥Ë´ã</button>
      <button class="join-status-btn" id="join-seat-btn">Â∏≠„ÇíÈÅ∏„Å∂</button>
      <button class="join-status-btn danger" id="join-cancel-btn">Âèñ„ÇäÊ∂à„Åó</button>
    </div>
  </div>

  <div class="table-area">
    <div class="table-felt"></div>
    <div class="players-ring" id="players-ring"></div>
    <div class="community-cards" id="community-cards"></div>
    <div class="pot-center">
      <div class="pot-label">POT</div>
      <div class="pot-amount" id="pot-amount">0</div>
    </div>
  </div>

  <div class="action-panel" id="action-panel">
    <div class="action-actor-label" id="actor-label">
      <strong>‚Äî</strong>„ÅÆ„Çø„Éº„É≥
    </div>
    <div class="action-lock-message" id="action-lock-message" style="display:none;">„ÅÇ„Å™„Åü„ÅÆÁï™„Å´„Å™„Çã„Åæ„Åß„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ</div>
    <div class="action-aux" id="action-aux">
      <label class="aux-toggle">
        <input type="checkbox" id="away-toggle">
        <span class="aux-toggle-track"></span>
        <span class="aux-toggle-text">Èõ¢Â∏≠‰∏≠</span>
      </label>
      <button class="aux-exit-btn" id="exit-next-hand-btn">Ê¨°„Éè„É≥„Éâ„ÅßÈÄÄÂá∫</button>
    </div>
    <div class="action-btns" id="action-btns"></div>
    <div class="raise-area" id="raise-area">
      <div class="raise-presets" id="raise-presets"></div>
      <div class="raise-min" id="raise-min-label"></div>
      <div class="raise-error" id="raise-error" style="display:none;"></div>
      <div class="raise-slider-row">
        <input type="range" id="raise-slider" min="0" max="100" value="30" oninput="onRaiseSlide()">
        <div class="raise-amount" id="raise-amount-display">0</div>
      </div>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ SHOWDOWN OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="showdown-overlay" id="showdown-overlay">
  <div class="showdown-card">
    <div class="showdown-title">„Ç∑„Éß„Éº„ÉÄ„Ç¶„É≥ - ÂãùËÄÖ„ÇíÈÅ∏Êäû</div>
    <div class="showdown-pot" id="showdown-pot-amount">0</div>
    <div class="showdown-pot-label">TOTAL POT</div>
    <div class="winner-select" id="winner-select"></div>
    <div class="split-toggle">
      <span class="split-label">„ÉÅ„Éß„ÉÉ„ÉóÔºàÂºï„ÅçÂàÜ„ÅëÔºâ</span>
      <div class="toggle-switch" id="split-toggle" onclick="toggleSplit()"></div>
    </div>
    <button class="confirm-winner-btn" id="confirm-winner-btn" onclick="confirmWinner()" disabled>Á¢∫ÂÆö</button>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ NEXT HAND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="next-hand-overlay" id="next-hand-overlay">
  <div class="next-hand-card">
    <div class="next-hand-winners" id="next-hand-winners"></div>
    <div class="next-hand-sub">„ÅÆÂãù„Å°ÔºÅ</div>
    <div class="next-hand-gain" id="next-hand-gain"></div>
    <div class="next-hand-chip-status" id="next-hand-chip-status"></div>
    <button class="next-hand-btn" id="next-hand-btn" onclick="nextHand()">Ê¨°„ÅÆ„Éè„É≥„Éâ</button>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ CHIP STATUS OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="chip-status-overlay" id="chip-status-overlay">
  <div class="chip-status-card">
    <div class="chip-status-title">„ÉÅ„ÉÉ„ÉóÁä∂Ê≥Å</div>
    <div class="chip-status-table" id="chip-status-table"></div>
    <button class="next-hand-btn" onclick="hideChipStatus(); nextHand();">Ê¨°„ÅÆ„Éè„É≥„Éâ</button>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ HAND HISTORY OVERLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="chip-status-overlay" id="history-overlay">
  <div class="chip-status-card" style="max-width: 400px;">
    <div class="chip-status-title">„Éè„É≥„ÉâÂ±•Ê≠¥</div>
    <div class="history-filters">
      <div class="history-filter">
        <input type="number" id="history-filter-hand" placeholder="„Éè„É≥„ÉâÁï™Âè∑">
      </div>
      <div class="history-filter">
        <input type="text" id="history-filter-winner" placeholder="ÂãùËÄÖÂêç">
      </div>
      <div class="history-filter">
        <input type="number" id="history-filter-minpot" placeholder="ÊúÄÂ∞è„Éù„ÉÉ„Éà">
      </div>
      <div class="history-filter-actions">
        <button class="history-filter-btn" id="history-filter-clear">„ÇØ„É™„Ç¢</button>
      </div>
    </div>
    <div class="history-list" id="history-list"></div>
    <button class="next-hand-btn" onclick="hideHistory()">Èñâ„Åò„Çã</button>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ WIN FLASH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="win-flash" id="win-flash"></div>

<div class="toast" id="toast"></div>

<!-- ‚îÄ‚îÄ‚îÄ RECONNECT / JOIN MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="confirm-dialog-overlay" id="reconnect-overlay">
  <div class="confirm-dialog">
    <div class="confirm-dialog-title" id="reconnect-title">ÈÄ≤Ë°å‰∏≠„ÅÆ„Ç≤„Éº„É†</div>
    <div class="confirm-dialog-message" id="reconnect-message">ÈÄ≤Ë°å‰∏≠„ÅÆ„Ç≤„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇÂèÇÂä†„Åó„Åæ„Åô„ÅãÔºü</div>
    <div class="reconnect-dialog-body">
      <div class="reconnect-row" id="reconnect-chip-row">
        <input class="reconnect-chip-input" id="reconnect-chips" type="number" min="1" step="1" inputmode="numeric" value="1000">
        <span class="reconnect-dialog-note">„ÉÅ„ÉÉ„ÉóÔºàÂàùÊúüÂÄ§Ôºâ</span>
      </div>
      <div class="reconnect-dialog-note" id="reconnect-note">ÂèÇÂä†„ÇíÈÅ∏„Å∂„Å®Ê¨°„ÅÆ„Éè„É≥„Éâ„Åã„ÇâÂÖ•„Çå„Åæ„Åô„ÄÇ</div>
    </div>
    <div class="confirm-dialog-buttons">
      <button class="confirm-dialog-btn cancel" id="reconnect-watch-btn">Ë¶≥Êà¶„Åô„Çã</button>
      <button class="confirm-dialog-btn primary" id="reconnect-play-btn">ÂèÇÂä†„Åô„Çã</button>
    </div>
    <div class="confirm-dialog-buttons" style="margin-top:10px;">
      <button class="confirm-dialog-btn danger" id="reconnect-cancel-btn">„Ç≠„É£„É≥„Çª„É´</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ SEAT SELECT MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="confirm-dialog-overlay" id="seat-select-overlay">
  <div class="confirm-dialog">
    <div class="confirm-dialog-title">Â∏≠„ÇíÈÅ∏Êäû</div>
    <div class="confirm-dialog-message">Á©∫„ÅÑ„Å¶„ÅÑ„ÇãÂ∏≠„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ</div>
    <div class="seat-select-grid" id="seat-select-grid"></div>
    <div class="confirm-dialog-buttons">
      <button class="confirm-dialog-btn cancel" id="seat-select-cancel-btn">„Ç≠„É£„É≥„Çª„É´</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ JOIN CANCEL CONFIRM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="confirm-dialog-overlay" id="join-cancel-overlay">
  <div class="confirm-dialog">
    <div class="confirm-dialog-title">ÂèÇÂä†„ÅÆÂèñ„ÇäÊ∂à„Åó</div>
    <div class="confirm-dialog-message">ÂèÇÂä†Áî≥Ë´ã„ÇíÂèñ„ÇäÊ∂à„Åó„Å¶Ë¶≥Êà¶„Å´Êàª„Çä„Åæ„Åô„ÅãÔºü</div>
    <div class="confirm-dialog-buttons">
      <button class="confirm-dialog-btn cancel" id="join-cancel-no">„Ç≠„É£„É≥„Çª„É´</button>
      <button class="confirm-dialog-btn danger" id="join-cancel-yes">Âèñ„ÇäÊ∂à„Åô</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ FOLD CONFIRM DIALOG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="confirm-dialog-overlay" id="fold-confirm-overlay">
  <div class="confirm-dialog">
    <div class="confirm-dialog-title">„Éï„Ç©„Éº„É´„Éâ„ÅÆÁ¢∫Ë™ç</div>
    <div class="confirm-dialog-message">„ÉÅ„Çß„ÉÉ„ÇØ„Åß„Åç„Åæ„Åô„Åå„ÄÅÊú¨ÂΩì„Å´„Éï„Ç©„Éº„É´„Éâ„Åó„Åæ„Åô„ÅãÔºü</div>
    <div class="confirm-dialog-buttons">
      <button class="confirm-dialog-btn cancel" id="fold-cancel-btn">„Ç≠„É£„É≥„Çª„É´</button>
      <button class="confirm-dialog-btn danger" id="fold-confirm-btn">„Éï„Ç©„Éº„É´„Éâ„Åô„Çã</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ DISCONNECT DIALOG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="confirm-dialog-overlay" id="disconnect-overlay">
  <div class="confirm-dialog">
    <div class="confirm-dialog-title">Êé•Á∂ö„ÅåÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü</div>
    <div class="confirm-dialog-message">„Çµ„Éº„Éê„Éº„Å®„ÅÆÊé•Á∂ö„ÅåÂ§±„Çè„Çå„Åæ„Åó„Åü„ÄÇÂÜçÊé•Á∂ö„ÇíÂæÖ„Å§„Åã„ÄÅ„Ç≤„Éº„É†„ÇíÁµÇ‰∫Ü„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</div>
    <div class="confirm-dialog-buttons">
      <button class="confirm-dialog-btn cancel" id="disconnect-wait-btn">ÂÜçÊé•Á∂ö„ÇíÂæÖ„Å§</button>
      <button class="confirm-dialog-btn danger" id="disconnect-exit-btn">„Ç≤„Éº„É†„ÇíÁµÇ‰∫Ü</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ SCRIPT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
// ========================================================
// GAME LOGIC (actedThisRoundÁâà - 32„ÉÜ„Çπ„ÉàÂÖ®ÈÄöÈÅé)
// ========================================================
const APP_VERSION = "v0.6.0";
let displayMode = localStorage.getItem('pokerDisplayMode') || 'chips';

function getBigBlindValue() {
  return gameState?.bigBlind
    || parseInt(document.getElementById('bb-input')?.value || '0', 10)
    || 20;
}

function formatBB(amount) {
  const bb = getBigBlindValue();
  if (!bb) return '0';
  const value = amount / bb;
  const rounded = Math.abs(value - Math.round(value)) < 0.01
    ? Math.round(value)
    : Math.round(value * 10) / 10;
  return String(rounded);
}

function formatAmount(amount) {
  if (displayMode === 'bb') return `${formatBB(amount)}BB`;
  return amount.toLocaleString();
}

function applyDisplayMode(mode) {
  displayMode = mode;
  localStorage.setItem('pokerDisplayMode', mode);
  const toggleBtn = document.getElementById('menu-display-toggle');
  if (toggleBtn) toggleBtn.textContent = `Ë°®Ë®òÂàáÊõø: ${displayMode === 'bb' ? 'BB' : 'CHIP'}`;
  render();
}

// ‚îÄ‚îÄ‚îÄ FX helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let fxAudioCtx = null;
let fxAudioUnlocked = false;
function getFxAudioCtx() {
  if (!fxAudioCtx) {
    fxAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return fxAudioCtx;
}
function unlockFxAudio() {
  try {
    const ctx = getFxAudioCtx();
    if (ctx.state === 'suspended') ctx.resume();
    fxAudioUnlocked = true;
  } catch (e) {}
}
document.addEventListener('click', unlockFxAudio, { once: true });
document.addEventListener('touchend', unlockFxAudio, { once: true });

function playTone({ freq = 660, duration = 0.18, type = 'sine', gain = 0.08 }) {
  try {
    const ctx = getFxAudioCtx();
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    g.gain.value = 0;
    osc.connect(g);
    g.connect(ctx.destination);
    const now = ctx.currentTime;
    g.gain.linearRampToValueAtTime(gain, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    osc.start(now);
    osc.stop(now + duration + 0.02);
  } catch (e) {}
}
function playPhaseChime() {
  if (!timerSettings.soundEnabled) return;
  playTone({ freq: 660, duration: 0.16, type: 'triangle', gain: 0.06 });
  setTimeout(() => playTone({ freq: 880, duration: 0.14, type: 'triangle', gain: 0.05 }), 80);
}
function playWinChime() {
  if (!timerSettings.soundEnabled) return;
  playTone({ freq: 523, duration: 0.2, type: 'sine', gain: 0.07 });
  setTimeout(() => playTone({ freq: 784, duration: 0.22, type: 'sine', gain: 0.06 }), 90);
}
function playAllInHit() {
  if (!timerSettings.soundEnabled) return;
  playTone({ freq: 196, duration: 0.12, type: 'square', gain: 0.05 });
}
function setTextWithBump(el, text) {
  if (!el) return;
  if (el.textContent === text) return;
  el.textContent = text;
  el.classList.remove('value-bump');
  void el.offsetWidth;
  el.classList.add('value-bump');
}
function triggerPhasePulse() {
  const table = document.querySelector('.table-area');
  if (!table) return;
  table.classList.remove('phase-pulse');
  void table.offsetWidth;
  table.classList.add('phase-pulse');
}
function hasNewAllIn(prevState, nextState) {
  if (!prevState || !nextState) return false;
  return nextState.players.some((p, i) => p.status === 'allIn' && prevState.players[i]?.status !== 'allIn');
}

let actionCounter = 0;
function newActionId() { return `act_${Date.now()}_${actionCounter++}`; }

function findNextActivePlayer(state, fromIndex) {
  const len = state.players.length;
  for (let i = 1; i <= len; i++) {
    const idx = (fromIndex + i) % len;
    if (state.players[idx].status === "active") return idx;
  }
  return -1;
}
function countActivePlayers(state) { return state.players.filter(p => p.status === "active").length; }
function countEligiblePlayers(state) { return state.players.filter(p => p.status !== "folded").length; }

function initGame(playerInput, smallBlind, bigBlind, initialChips = 1000) {
  const players = playerInput.map((entry, i) => {
    const name = typeof entry === 'string' ? entry : (entry?.name || '');
    const icon = typeof entry === 'string' ? '' : (entry?.icon || '');
    const finalName = name || icon || `„Éó„É¨„Ç§„É§„Éº${i + 1}`;
    const stack = typeof entry === 'string' ? initialChips : (entry?.startingChips || initialChips);
    return {
      id: `player_${i}`, name: finalName, icon, chips: stack,
      status: "waiting", currentBet: 0, totalBet: 0,
      actedThisRound: false  // ‚òÖ „É©„Ç¶„É≥„ÉâÂÜÖ„Ç¢„ÇØ„Ç∑„Éß„É≥Ê∏à„Åø„Éï„É©„Ç∞
    };
  });
  return {
    players, smallBlind, bigBlind,
    phase: "preflop", currentPlayerIndex: 0, dealerIndex: 0,
    pots: [], currentMaxBet: 0, lastRaiseSize: bigBlind, actionHistory: [],
    isHandActive: false
  };
}

function postBlind(state, playerIndex, amount) {
  const s = { ...state, players: state.players.map(p => ({...p})), pots: state.pots.map(p => ({...p})) };
  const player = s.players[playerIndex];
  const actualAmount = Math.min(amount, player.chips);
  player.chips -= actualAmount;
  player.currentBet = actualAmount;
  player.totalBet += actualAmount;
  if (player.chips === 0) player.status = "allIn";
  if (s.pots.length > 0) s.pots[0].amount += actualAmount;
  // ‚òÖ „Éñ„É©„Ç§„É≥„Éâ„ÅØ„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®„Åó„Å¶„Ç´„Ç¶„É≥„Éà„Åó„Å™„ÅÑ
  return s;
}

function startHand(state) {
  // „ÉÅ„ÉÉ„Éó0„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅØ "out" „Å´„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅØ "active" „Å´
  let s = {
    ...state, isHandActive: true, phase: "preflop",
    players: state.players.map(p => ({
      ...p,
      status: p.chips > 0 ? "active" : "out",
      currentBet: 0,
      actedThisRound: false
    })),
    pots: [{ amount: 0, eligiblePlayerIds: state.players.filter(p => p.chips > 0).map(p => p.id) }],
    actionHistory: []
  };

  // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Éó„É¨„Ç§„É§„Éº„Åå1‰∫∫‰ª•‰∏ã„Å™„Çâ„Ç≤„Éº„É†ÁµÇ‰∫Ü
  const activePlayers = s.players.filter(p => p.status === "active");
  if (activePlayers.length <= 1) {
    s.isHandActive = false;
    s.phase = "finished";
    return s;
  }

  const n = s.players.length;

  // „ÉÅ„ÉÉ„Éó„Åå„ÅÇ„Çã„Éó„É¨„Ç§„É§„Éº„ÅÆ‰∏≠„Åß„Éá„Ç£„Éº„É©„Éº/„Éñ„É©„Ç§„É≥„Éâ„ÇíÊ±∫„ÇÅ„Çã
  const findNextWithChips = (fromIdx) => {
    for (let i = 1; i <= n; i++) {
      const idx = (fromIdx + i) % n;
      if (s.players[idx].chips > 0) return idx;
    }
    return fromIdx;
  };

  const sbIdx = n === 2 ? s.dealerIndex : findNextWithChips(s.dealerIndex);
  const bbIdx = findNextWithChips(sbIdx);
  s = postBlind(s, sbIdx, s.smallBlind);
  s = postBlind(s, bbIdx, s.bigBlind);
  s.currentMaxBet = s.bigBlind;
  s.lastRaiseSize = s.bigBlind;

  // BB„ÅÆÊ¨°„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Éó„É¨„Ç§„É§„Éº„ÇíÊé¢„Åô
  const firstToAct = findNextWithChips(bbIdx);
  s.currentPlayerIndex = firstToAct !== bbIdx ? firstToAct : findNextWithChips(firstToAct);

  return s;
}

function validateAction(state, type, amount) {
  const player = state.players[state.currentPlayerIndex];
  const callAmt = state.currentMaxBet - player.currentBet;
  switch (type) {
    case "fold": return { resolvedAmount: 0 };
    case "check":
      if (callAmt > 0) return { error: "„Ç≥„Éº„É´„ÅåÂøÖË¶Å„Åß„Åô" };
      return { resolvedAmount: 0 };
    case "call":
      if (callAmt === 0) return { error: "„Ç≥„Éº„É´„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åõ„Çì" };
      return { resolvedAmount: Math.min(callAmt, player.chips) };
    case "raise": {
      // Min raise: previous bet/raise size. All-in below min does not reopen action.
      // Sources: https://oag.ca.gov/sites/all/files/agweb/pdfs/gambling/oceans-eleven.pdf
      //          https://www.pokerstars.com/help/articles/poker-rules-master/
      const need = amount - player.currentBet;
      const minRaiseTo = state.currentMaxBet + state.lastRaiseSize;
      const allInTo = player.currentBet + player.chips;
      if (amount < minRaiseTo && amount < allInTo) {
        return { error: `„É¨„Ç§„Ç∫È°ç„ÅØÊúÄ‰Ωé ${minRaiseTo}` };
      }
      if (amount >= allInTo) return { resolvedAmount: player.chips, isShortAllIn: amount < minRaiseTo };
      return { resolvedAmount: need };
    }
    default: return { error: "‰∏çÊòé" };
  }
}

function addToMainPot(pots, amount) {
  if (pots.length === 0) return [{ amount, eligiblePlayerIds: [] }];
  return pots.map((p, i) => i === 0 ? { ...p, amount: p.amount + amount } : p);
}

function applyAction(state, playerIdx, type, amount, meta = {}) {
  const s = { ...state, players: state.players.map(p => ({...p})), pots: state.pots.map(p => ({...p})) };
  const player = s.players[playerIdx];
  const prevMax = s.currentMaxBet;
  
  // ‚òÖ „Ç¢„ÇØ„Ç∑„Éß„É≥Ê∏à„Åø„Éï„É©„Ç∞„Çí„Çª„ÉÉ„Éà
  player.actedThisRound = true;

  switch (type) {
    case "fold": 
      player.status = "folded"; 
      break;
    case "check": 
      break;
    case "call":
      player.chips -= amount; 
      player.currentBet += amount; 
      player.totalBet += amount;
      if (player.chips === 0) player.status = "allIn";
      s.pots = addToMainPot(s.pots, amount); 
      break;
    case "raise":
      player.chips -= amount; 
      player.currentBet += amount; 
      player.totalBet += amount;
      s.currentMaxBet = player.currentBet;
      if (player.chips === 0) player.status = "allIn";
      s.pots = addToMainPot(s.pots, amount);
      {
        const raiseSize = player.currentBet - prevMax;
        const isFullRaise = raiseSize >= s.lastRaiseSize;
        if (isFullRaise) {
          s.lastRaiseSize = raiseSize;
          // ‚òÖ „Éï„É´„É¨„Ç§„Ç∫ÊôÇ: ‰ªñ„ÅÆÂÖ®„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Éó„É¨„Ç§„É§„Éº„ÅÆacted„Çífalse„Å´„É™„Çª„ÉÉ„Éà
          s.players.forEach((p, i) => {
            if (i !== playerIdx && p.status === "active") p.actedThisRound = false;
          });
        }
      }
      break;
  }
  const next = findNextActivePlayer(s, playerIdx);
  s.currentPlayerIndex = next !== -1 ? next : playerIdx;
  return s;
}

function advanceToNextPhase(state) {
  const s = { ...state, players: state.players.map(p => ({...p})), pots: (state.pots||[]).map(p => ({...p})) };
  const order = ["preflop","flop","turn","river","showdown"];
  const ci = order.indexOf(s.phase);
  if (ci >= order.length - 1) { s.phase = "showdown"; s.isHandActive = false; return s; }
  s.phase = order[ci + 1];
  if (s.phase === "showdown") { s.isHandActive = false; return s; }
  // ‚òÖ Êñ∞„Åó„ÅÑ„É©„Ç¶„É≥„ÉâÂàùÊúüÂåñ
  s.currentMaxBet = 0;
  s.lastRaiseSize = s.bigBlind;
  s.players = s.players.map(p => ({ ...p, currentBet: 0, actedThisRound: false }));
  const first = findNextActivePlayer(s, s.dealerIndex);
  s.currentPlayerIndex = first !== -1 ? first : s.currentPlayerIndex;
  return s;
}

function endHand(state) {
  const s = { ...state, players: state.players.map(p => ({...p})), pots: [...(state.pots||[])] };
  s.phase = "showdown";
  s.isHandActive = false;
  // „Éù„ÉÉ„Éà„ÅØÈÖçÂàÜ„Åó„Å™„ÅÑÔºàshowShowdown„ÅßÂãùËÄÖÁ¢∫Ë™çÂæå„Å´ÈÖçÂàÜÔºâ
  return s;
}

function checkAndAdvancePhase(state) {
  let s = { ...state };
  
  // ÂÖ®Âì°„Éï„Ç©„Éº„É´„ÉâÂà§ÂÆö
  if (countEligiblePlayers(s) === 1) return endHand(s);
  
  // „Åæ„Å†betÈ°ç„Å´Âêà„Çè„Åõ„Å¶„ÅÑ„Å™„ÅÑ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Éó„É¨„Ç§„É§„Éº„Åå„ÅÑ„Çã ‚Üí Á∂öË°å
  const hasUnmatched = s.players.some(p => p.status === "active" && p.currentBet < s.currentMaxBet);
  if (hasUnmatched) return s;
  
  // ‚òÖ „Åæ„Å†„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅåÊ∏à„Çì„Åß„ÅÑ„Å™„ÅÑ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Éó„É¨„Ç§„É§„Éº„Åå„ÅÑ„Çã ‚Üí Á∂öË°å
  const hasUnacted = s.players.some(p => p.status === "active" && !p.actedThisRound);
  if (hasUnacted) return s;
  
  // ÂÖ®Âì°matched + ÂÖ®Âì°acted ‚Üí „É©„Ç¶„É≥„ÉâÂÆå‰∫Ü
  if (countActivePlayers(s) <= 1) {
    s = advanceToNextPhase(s);
    while (s.phase !== "showdown" && countActivePlayers(s) <= 1) s = advanceToNextPhase(s);
    return s;
  }
  
  // ÈÄöÂ∏∏„É©„Ç¶„É≥„ÉâÂÆå‰∫Ü
  s = advanceToNextPhase(s);
  return s;
}

function processAction(state, actionType, amount = 0) {
  if (!state.isHandActive) return { error: "„Éè„É≥„Éâ„ÅåÈÄ≤Ë°å„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì" };
  const playerIdx = state.currentPlayerIndex;
  const player = state.players[playerIdx];
  if (player.status !== "active") return { error: "„Ç¢„ÇØ„Ç∑„Éß„É≥‰∏çÂèØ" };
  const v = validateAction(state, actionType, amount);
  if (v.error) return { error: v.error };
  let s = applyAction(state, playerIdx, actionType, v.resolvedAmount, v);
  s.actionHistory = [...(s.actionHistory||[]), {
    id: newActionId(), type: actionType, playerId: player.id,
    amount: v.resolvedAmount, timestamp: Date.now()
  }];
  s = checkAndAdvancePhase(s);
  return s;
}

function distributePot(state, winnerIds) {
  const s = { ...state, players: state.players.map(p => ({...p})) };
  const total = (s.pots||[]).reduce((sum, p) => sum + p.amount, 0);
  if (winnerIds.length === 0) return s;
  const per = Math.floor(total / winnerIds.length);
  const rem = total - per * winnerIds.length;
  s.players = s.players.map((p, i) => {
    if (winnerIds.includes(p.id)) {
      const bonus = i === s.players.findIndex(pl => winnerIds.includes(pl.id)) ? rem : 0;
      return { ...p, chips: p.chips + per + bonus };
    }
    return p;
  });
  s.pots = [];
  return s;
}

function advanceDealer(state) {
  return { ...state, dealerIndex: (state.dealerIndex + 1) % state.players.length };
}

// ========================================================
// UI STATE & RENDERING
// ========================================================
let gameState = null;
let raiseValue = 0;           // ÁèæÂú®„ÅÆ„É¨„Ç§„Ç∫È°çÔºàÁµ∂ÂØæÂÄ§Ôºâ
let selectedWinners = [];     // showdownÊôÇ„ÅÆÂãùËÄÖÈÅ∏Êäû
let isSplitMode = false;
let handHistory = [];         // „Éè„É≥„ÉâÂ±•Ê≠¥
let chipsBeforeHand = {};     // „Éè„É≥„ÉâÈñãÂßãÊôÇ„ÅÆ„ÉÅ„ÉÉ„Éó
let lastCommunityCount = 0;
let lastPhase = null;
let lastPhaseFx = null;
let confirmLock = false;
let nextHandLock = false;
let perPlayerStackChips = {};
let winnerHighlightIds = [];
let winnerHighlightTimer = null;

// Timer state
let timerSettings = { duration: 0, soundEnabled: true };
let actionTimer = null;
let timeRemaining = 0;
let timerStartTime = 0;

// Tournament state
let tournamentSettings = { enabled: false, levelDuration: 15 };
let tournamentTimer = null;
let tournamentTimeRemaining = 0;
let currentBlindLevel = 1;
const SOUND_STORAGE_KEY = 'pokerSoundEnabled';
let lateJoinSettings = { enabled: true, maxChips: 1000 };

// Online sync (Supabase Realtime)
const SUPABASE_URL = "https://tpucsakhvzkincyvyscn.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_ZU269gj6MzgeSra0gUeQ-A_I_9v2giq";
let supabaseClient = null;
let roomChannel = null;
let reconnectTimer = null;
let hostAbsentTimer = null;
let hostAbsentDeadline = 0;
let joinChoiceConfirmed = false;
let autoEnterOnStateSync = false;
let onlineState = {
  role: "local", // local | host | player
  roomCode: "",
  connected: false,
  displayName: "",
  seat: "",
  ready: false,
  joinMode: "play", // play | watch
  requestedChips: 1000,
  joinConfirmed: false,
  rebuyRequested: false,
  away: false,
  pendingExit: false
};
let onlineReady = false;
let uiState = 'room'; // room | waiting | settings | playing
const RECONNECT_STORAGE_KEY = 'pokerReconnectInfo';
let reconnectInfo = null;
let reconnectContext = null;

const COMMUNITY_SUITS = ['‚ô†','‚ô£','‚ô•','‚ô¶','‚ô†'];
const boundEvents = new WeakMap();
function bindOnce(el, type, handler, options) {
  if (!el) return;
  let map = boundEvents.get(el);
  if (!map) {
    map = {};
    boundEvents.set(el, map);
  }
  if (map[type]) return;
  map[type] = true;
  el.addEventListener(type, handler, options);
}

function debounce(fn, wait = 120) {
  let t = null;
  return (...args) => {
    if (t) clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
}

function setupNumericInput(el) {
  if (!el) return;
  el.setAttribute('inputmode', 'numeric');
  el.setAttribute('pattern', '[0-9]*');
  el.setAttribute('enterkeyhint', 'done');
  const normalize = debounce(() => {
    const cleaned = (el.value || '').replace(/[^\d]/g, '');
    if (el.value !== cleaned) el.value = cleaned;
  }, 120);
  bindOnce(el, 'input', normalize);
  bindOnce(el, 'focus', () => el.select(), { passive: true });
}

function getPotTotal(state) {
  return (state.pots || []).reduce((sum, p) => sum + p.amount, 0);
}

const debugEnabled = new URLSearchParams(window.location.search).get('debug') === '1';
let debugPanel = null;
let debugLogEl = null;
function initDebugPanel() {
  if (!debugEnabled || debugPanel) return;
  debugPanel = document.createElement('div');
  debugPanel.id = 'debug-panel';
  debugPanel.innerHTML = `
    <header>
      <span>Debug</span>
      <span id="debug-toggle">‚ñæ</span>
    </header>
    <div class="content" id="debug-content"></div>
  `;
  document.body.appendChild(debugPanel);
  debugLogEl = debugPanel.querySelector('#debug-content');
  const header = debugPanel.querySelector('header');
  bindOnce(header, 'click', () => {
    debugPanel.classList.toggle('collapsed');
  });
}
function debugLog(msg) {
  if (!debugEnabled) return;
  if (!debugPanel) initDebugPanel();
  if (!debugLogEl) return;
  const line = document.createElement('div');
  line.textContent = msg;
  debugLogEl.appendChild(line);
  debugLogEl.scrollTop = debugLogEl.scrollHeight;
}

function initSupabase() {
  if (!window.supabase || supabaseClient) return;
  supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
}

function loadReconnectInfo() {
  try {
    const raw = localStorage.getItem(RECONNECT_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return null;
    return parsed;
  } catch (e) {
    return null;
  }
}

function saveReconnectInfo(patch = {}) {
  const base = reconnectInfo && typeof reconnectInfo === 'object' ? reconnectInfo : {};
  reconnectInfo = { ...base, ...patch, updatedAt: Date.now() };
  try {
    localStorage.setItem(RECONNECT_STORAGE_KEY, JSON.stringify(reconnectInfo));
  } catch (e) {}
}

function clearReconnectInfo() {
  reconnectInfo = null;
  try {
    localStorage.removeItem(RECONNECT_STORAGE_KEY);
  } catch (e) {}
}

function updatePresence(extra = {}) {
  if (!roomChannel) return;
  const payload = {
    role: onlineState.role,
    name: onlineState.displayName,
    joinedAt: onlineState.joinedAt || Date.now(),
    seat: onlineState.seat || "",
    ready: !!onlineState.ready,
    joinMode: onlineState.joinMode || "play",
    requestedChips: onlineState.requestedChips || 1000,
    joinConfirmed: !!onlineState.joinConfirmed,
    rebuyRequested: !!onlineState.rebuyRequested,
    away: !!onlineState.away,
    pendingExit: !!onlineState.pendingExit,
    ...extra
  };
  onlineState.joinedAt = payload.joinedAt;
  roomChannel.track(payload);
}

function scheduleReconnect() {
  if (reconnectTimer) return;
  if (!onlineState.roomCode || onlineState.role === 'local') return;
  reconnectTimer = setTimeout(async () => {
    reconnectTimer = null;
    const role = onlineState.role;
    const code = onlineState.roomCode;
    await joinRoom(role, code);
  }, 1500);
}

function startHostAbsentTimer() {
  if (hostAbsentTimer) return;
  hostAbsentDeadline = Date.now() + 60000;
  setRoomStatus('„Éõ„Çπ„Éà„Åå‰∏çÂú®„Åß„Åô„ÄÇ60ÁßíÂæÖÊ©ü‰∏≠‚Ä¶');
  hostAbsentTimer = setTimeout(() => {
    hostAbsentTimer = null;
    hostAbsentDeadline = 0;
    if (onlineState.role !== 'host' && onlineState.connected) {
      leaveRoom();
      setRoomStatus('„Éõ„Çπ„Éà‰∏çÂú®„ÅÆ„Åü„ÇÅÈÄÄÂá∫„Åó„Åæ„Åó„Åü');
    }
  }, 60000);
}

function clearHostAbsentTimer() {
  if (!hostAbsentTimer) return;
  clearTimeout(hostAbsentTimer);
  hostAbsentTimer = null;
  hostAbsentDeadline = 0;
}

function setUiState(state) {
  uiState = state;
  const screenMap = {
    room: 'room-screen',
    waiting: 'waiting-screen',
    settings: 'settings-screen',
    playing: 'game-screen'
  };
  const activeScreenId = screenMap[state];
  const activeEl = document.activeElement;
  if (activeEl && typeof activeEl.blur === 'function') {
    activeEl.blur();
  }
  const screens = Object.values(screenMap);
  screens.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.classList.toggle('hidden', id !== activeScreenId);
  });
  const activeScreen = document.getElementById(activeScreenId);
  if (activeScreen) {
    activeScreen.scrollTop = 0;
  }
  window.scrollTo(0, 0);
  if (state !== 'playing') {
    document.getElementById('showdown-overlay').classList.remove('visible');
    document.getElementById('next-hand-overlay').classList.remove('visible');
    document.getElementById('fold-confirm-overlay').classList.remove('visible');
  }
  if (state === 'waiting' || state === 'settings') {
    updateParticipantList();
  }
  if (state === 'settings') {
    updateSettingsPanels();
  }
  updateHeaderMenuVisibility();
  updateJoinMenuVisibility();
  updateJoinStatusBanner();
  updateSoundMenuLabel();
  updateJoinStatusMenuLabel();
  updatePlayerBadge();
  updateAwayControls();
  if (state === 'playing' && onlineState.role !== 'local') {
    saveReconnectInfo({
      roomCode: onlineState.roomCode,
      role: onlineState.role,
      displayName: onlineState.displayName,
      joinMode: onlineState.joinMode || 'play',
      requestedChips: onlineState.requestedChips || 1000,
      wasPlaying: true
    });
  }
  if (state === 'room' && onlineState.role !== 'local' && onlineState.roomCode) {
    saveReconnectInfo({ wasPlaying: false });
  }
}

function updateHeaderMenuVisibility() {
  const menuBtn = document.getElementById('menu-btn');
  if (!menuBtn) return;
  menuBtn.style.display = 'inline-flex';
}

function updateJoinMenuVisibility() {
  const joinBtn = document.getElementById('menu-join-btn');
  if (!joinBtn) return;
  const show = onlineState.role === 'player' && onlineState.joinMode === 'watch';
  joinBtn.style.display = show ? 'inline-flex' : 'none';
}

function updatePlayerBadge() {
  const nameEl = document.getElementById('player-name-tag');
  const roleEl = document.getElementById('player-role-tag');
  if (!nameEl || !roleEl) return;
  const name = onlineState.displayName || '‚Äî';
  const role = onlineState.role === 'host' ? 'HOST' : onlineState.role === 'player' ? 'PLAYER' : 'LOCAL';
  nameEl.textContent = name;
  roleEl.textContent = role;
  roleEl.classList.toggle('host', onlineState.role === 'host');
  roleEl.classList.toggle('player', onlineState.role !== 'host');
}

function showReconnectModal(options = {}) {
  const overlay = document.getElementById('reconnect-overlay');
  if (!overlay) return;
  const titleEl = document.getElementById('reconnect-title');
  const messageEl = document.getElementById('reconnect-message');
  const chipsRow = document.getElementById('reconnect-chip-row');
  const chipsInput = document.getElementById('reconnect-chips');
  const watchBtn = document.getElementById('reconnect-watch-btn');
  const playBtn = document.getElementById('reconnect-play-btn');
  const noteEl = document.getElementById('reconnect-note');
  const role = options.role || onlineState.role;
  const roomCode = options.roomCode || onlineState.roomCode || '';

  if (titleEl) titleEl.textContent = options.title || 'ÈÄ≤Ë°å‰∏≠„ÅÆ„Ç≤„Éº„É†';
  if (messageEl) {
    const base = options.message || 'ÈÄ≤Ë°å‰∏≠„ÅÆ„Ç≤„Éº„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇÂèÇÂä†„Åó„Åæ„Åô„ÅãÔºü';
    messageEl.textContent = roomCode ? `${base}Ôºà„Ç≥„Éº„Éâ: ${roomCode}Ôºâ` : base;
  }
  if (noteEl) {
    noteEl.textContent = options.note || 'ÂèÇÂä†„ÇíÈÅ∏„Å∂„Å®Ê¨°„ÅÆ„Éè„É≥„Éâ„Åã„ÇâÂÖ•„Çå„Åæ„Åô„ÄÇ';
  }

  const showWatch = role !== 'host' && options.showWatch !== false;
  if (watchBtn) watchBtn.style.display = showWatch ? 'inline-flex' : 'none';
  if (playBtn) playBtn.textContent = role === 'host' ? 'ÂÜçÊé•Á∂ö„Åô„Çã' : 'ÂèÇÂä†„Åô„Çã';
  if (chipsRow) chipsRow.style.display = role === 'host' ? 'none' : 'flex';
  if (chipsInput) {
    const defaultChips = options.defaultChips || onlineState.requestedChips || 1000;
    chipsInput.value = String(defaultChips);
  }

  reconnectContext = options.context || 'unknown';
  overlay.classList.add('visible');
}

function hideReconnectModal() {
  const overlay = document.getElementById('reconnect-overlay');
  if (overlay) overlay.classList.remove('visible');
  reconnectContext = null;
}

function getRequestedChips() {
  const input = document.getElementById('reconnect-chips');
  const value = input ? parseInt(input.value, 10) : NaN;
  return Number.isFinite(value) && value >= 1 ? value : 1000;
}

function getAutoJoinChips() {
  const max = gameState?.lateJoinSettings?.maxChips ?? lateJoinSettings.maxChips ?? 1000;
  return Number.isFinite(max) && max >= 1 ? max : 1000;
}

function applyJoinMode(mode, requestedChips) {
  onlineState.joinMode = mode;
  if (mode === 'play') {
    onlineState.requestedChips = requestedChips || 1000;
  } else {
    onlineState.ready = false;
    onlineState.seat = '';
    onlineState.away = false;
    onlineState.pendingExit = false;
  }
  joinChoiceConfirmed = true;
  onlineState.joinConfirmed = true;
  updateJoinMenuVisibility();
  updateJoinStatusBanner();
  updateAwayControls();
  saveReconnectInfo({
    roomCode: onlineState.roomCode,
    role: onlineState.role,
    displayName: onlineState.displayName,
    joinMode: onlineState.joinMode,
    requestedChips: onlineState.requestedChips || 1000
  });
  if (roomChannel) {
    updatePresence({ joinMode: onlineState.joinMode, requestedChips: onlineState.requestedChips });
  }
}

function isSelfInGame() {
  if (!gameState || !gameState.players) return false;
  return gameState.players.some(p => p.name === onlineState.displayName);
}

function getSelfPlayer() {
  if (!gameState || !gameState.players) return null;
  return gameState.players.find(p => p.name === onlineState.displayName) || null;
}

function updateJoinStatusBanner() {
  const banner = document.getElementById('join-status-banner');
  const titleEl = document.getElementById('join-status-title');
  const subEl = document.getElementById('join-status-sub');
  const progressEl = document.getElementById('join-progress-bar');
  const seatBtn = document.getElementById('join-seat-btn');
  const rebuyBtn = document.getElementById('rebuy-request-btn');
  const cancelBtn = document.getElementById('join-cancel-btn');
  if (!banner || !titleEl || !subEl || !progressEl) return;
  const selfPlayer = getSelfPlayer();
  const rebuyEligible = onlineState.role === 'player' && selfPlayer && selfPlayer.chips <= 0;
  const pendingJoin = onlineState.role === 'player' &&
    onlineState.joinMode === 'play' &&
    gameState?.isHandActive &&
    !isSelfInGame();
  banner.classList.toggle('visible', !!pendingJoin || !!rebuyEligible);
  if (rebuyEligible) {
    titleEl.textContent = '„É™„Éê„Ç§ÂæÖÊ©ü';
    subEl.textContent = 'Ê¨°„Éè„É≥„Éâ„Åã„Çâ„É™„Éê„Ç§„Åß„Åç„Åæ„ÅôÔºà„Éõ„Çπ„ÉàË®≠ÂÆöÈ°çÔºâ';
    progressEl.style.width = '0%';
    if (rebuyBtn) rebuyBtn.style.display = 'inline-flex';
    if (seatBtn) seatBtn.style.display = 'none';
    if (cancelBtn) cancelBtn.style.display = 'none';
  } else if (pendingJoin) {
    const lateJoinAllowed = canLateJoin();
    const seatText = onlineState.seat ? `Seat ${onlineState.seat} ÈÅ∏ÊäûÊ∏à„Åø` : 'Â∏≠„ÅåÊú™ÈÅ∏Êäû„Åß„Åô';
    let estimateText = 'ÈÄ≤Ë°åÁä∂Ê≥Å„Å´„Çà„ÇäÂâçÂæå„Åó„Åæ„Åô';
    let pct = 0;
    if (timerSettings.duration > 0 && timeRemaining > 0) {
      estimateText = `ÁõÆÂÆâ: Á¥Ñ${Math.ceil(timeRemaining)}Áßí`;
      pct = Math.min(1, Math.max(0, 1 - timeRemaining / timerSettings.duration));
    }
    titleEl.textContent = 'ÂèÇÂä†ÂæÖÊ©ü‰∏≠';
    subEl.textContent = lateJoinAllowed
      ? `Ê¨°„Éè„É≥„ÉâÈñãÂßã„ÅßÂèÇÂä†„Åó„Åæ„Åô„ÄÇ${seatText} / ${estimateText}`
      : 'ÁèæÂú®„Éõ„Çπ„ÉàË®≠ÂÆö„ÅßÈÄî‰∏≠ÂèÇÂä†„ÅåÁÑ°Âäπ„Åß„Åô';
    if (seatBtn) seatBtn.disabled = !lateJoinAllowed;
    if (seatBtn) seatBtn.style.display = 'inline-flex';
    if (cancelBtn) cancelBtn.style.display = 'inline-flex';
    if (rebuyBtn) rebuyBtn.style.display = 'none';
    progressEl.style.width = `${Math.round(pct * 100)}%`;
  } else {
    if (rebuyBtn) rebuyBtn.style.display = 'none';
    if (seatBtn) seatBtn.style.display = 'inline-flex';
    if (cancelBtn) cancelBtn.style.display = 'inline-flex';
  }
  updateJoinStatusMenuLabel();
}

function showSeatSelectModal() {
  const overlay = document.getElementById('seat-select-overlay');
  const grid = document.getElementById('seat-select-grid');
  if (!overlay || !grid) return;
  if (!canLateJoin()) {
    showToast('ÈÄî‰∏≠ÂèÇÂä†„ÅØ„Éõ„Çπ„ÉàË®≠ÂÆö„ÅßÁÑ°Âäπ„Åß„Åô');
    return;
  }
  grid.innerHTML = '';
  const list = getPresenceList().filter(p => !isSpectator(p));
  const usedSeats = new Map();
  list.forEach(p => {
    if (p.seat) usedSeats.set(String(p.seat), p);
  });
  for (let i = 1; i <= 8; i++) {
    const btn = document.createElement('button');
    btn.className = 'seat-select-btn';
    const occupant = usedSeats.get(String(i));
    if (occupant && occupant.name !== onlineState.displayName) {
      btn.classList.add('taken');
      btn.textContent = `Seat ${i}`;
      btn.disabled = true;
    } else {
      btn.textContent = `Seat ${i}`;
      if (onlineState.seat === String(i)) {
        btn.classList.add('active');
      }
      btn.addEventListener('click', () => {
        onlineState.seat = String(i);
        onlineState.ready = true;
        updatePresence({ seat: onlineState.seat, ready: onlineState.ready });
        updateParticipantList();
        updateJoinStatusBanner();
        hideSeatSelectModal();
        showToast(`Seat ${i} „ÇíÈÅ∏Êäû„Åó„Åæ„Åó„Åü„ÄÇÊ¨°„Éè„É≥„Éâ„Åã„ÇâÂèÇÂä†„Åó„Åæ„Åô`);
      });
    }
    grid.appendChild(btn);
  }
  overlay.classList.add('visible');
}

function hideSeatSelectModal() {
  const overlay = document.getElementById('seat-select-overlay');
  if (overlay) overlay.classList.remove('visible');
}

function showToast(message) {
  const toast = document.getElementById('toast');
  if (!toast) return;
  toast.textContent = message;
  toast.classList.add('visible');
  clearTimeout(toast._t);
  toast._t = setTimeout(() => {
    toast.classList.remove('visible');
  }, 1800);
}

function showJoinCancelConfirm() {
  const overlay = document.getElementById('join-cancel-overlay');
  if (overlay) overlay.classList.add('visible');
}

function hideJoinCancelConfirm() {
  const overlay = document.getElementById('join-cancel-overlay');
  if (overlay) overlay.classList.remove('visible');
}

function maybeShowReconnectPrompt() {
  if (roomChannel || uiState !== 'room') return;
  reconnectInfo = reconnectInfo || loadReconnectInfo();
  if (!reconnectInfo || !reconnectInfo.roomCode || !reconnectInfo.wasPlaying) return;
  if (reconnectInfo.role === 'local') return;
  if (onlineState.displayName === '' && reconnectInfo.displayName) {
    const nameInput = document.getElementById('display-name-input');
    if (nameInput && !nameInput.value) {
      nameInput.value = reconnectInfo.displayName;
    }
  }
  autoEnterOnStateSync = true;
  onlineState.requestedChips = getAutoJoinChips();
  joinRoom(reconnectInfo.role || 'player', reconnectInfo.roomCode, true);
}

function setRoomStatus(text) {
  const el = document.getElementById('room-status');
  if (el) el.textContent = text;
}

function setRoomControls(connected) {
  const leaveBtn = document.getElementById('room-leave-btn');
  if (leaveBtn) leaveBtn.style.display = connected ? 'inline-flex' : 'none';
}

function normalizeRoomCode(code) {
  return (code || '').toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 6);
}

function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let out = '';
  for (let i = 0; i < 6; i++) {
    out += chars[Math.floor(Math.random() * chars.length)];
  }
  return out;
}

function isSpectator(p) {
  return p && p.joinMode === 'watch';
}

function getPresenceList() {
  if (!roomChannel) return [];
  const presenceState = roomChannel.presenceState();
  const list = Object.values(presenceState).flat().map(p => ({ ...p, online: true }));
  return list.sort((a, b) => {
    const seatA = parseInt(a.seat || '0', 10) || 0;
    const seatB = parseInt(b.seat || '0', 10) || 0;
    if (seatA && seatB) return seatA - seatB;
    if (seatA && !seatB) return -1;
    if (!seatA && seatB) return 1;
    return (a.joinedAt || 0) - (b.joinedAt || 0);
  });
}

function isPlayerAway(name) {
  if (!name) return false;
  const list = getPresenceList();
  const player = list.find(p => p.name === name && p.role === 'player');
  return !!(player && player.away);
}

function updateAwayControls() {
  const aux = document.getElementById('action-aux');
  const toggle = document.getElementById('away-toggle');
  const exitBtn = document.getElementById('exit-next-hand-btn');
  if (!aux || !toggle || !exitBtn) return;
  const hasHand = !!(gameState && gameState.isHandActive);
  const show = hasHand && uiState === 'playing' && onlineState.role === 'player' && onlineState.joinMode === 'play';
  aux.style.display = show ? 'flex' : 'none';
  if (!show) return;
  toggle.checked = !!onlineState.away;
  exitBtn.classList.toggle('pending', !!onlineState.pendingExit);
  exitBtn.textContent = onlineState.pendingExit ? 'ÈÄÄÂá∫‰∫àÁ¥Ñ‰∏≠' : 'Ê¨°„Éè„É≥„Éâ„ÅßÈÄÄÂá∫';
}

function renderSeatRing(list) {
  const ring = document.getElementById('seat-ring');
  if (!ring) return;
  ring.innerHTML = '<div class="seat-center">TABLE</div>';
  const seats = 8;
  const cx = 50;
  const cy = 50;
  const rx = 42;
  const ry = 36;
  const used = new Map();
  list.forEach(p => {
    if (p.seat) used.set(String(p.seat), p);
  });
  for (let i = 1; i <= seats; i++) {
    const angle = ((i - 1) / seats) * 2 * Math.PI - Math.PI / 2;
    const x = cx + rx * Math.cos(angle);
    const y = cy + ry * Math.sin(angle);
    const seat = document.createElement('button');
    seat.className = 'seat-node';
    seat.style.left = `${x}%`;
    seat.style.top = `${y}%`;
    seat.style.transform = 'translate(-50%, -50%)';
    const occupant = used.get(String(i));
    if (occupant) {
      seat.classList.add('taken');
      seat.innerHTML = `<div>${occupant.name || 'Guest'}</div><div class="seat-label">Seat ${i}</div>`;
      if (occupant.name === onlineState.displayName) {
        seat.classList.remove('taken');
        seat.classList.add('active');
      }
    } else {
      seat.innerHTML = `<div>Seat ${i}</div>`;
    }
    seat.dataset.seat = String(i);
    seat.addEventListener('click', () => {
      if (onlineState.joinMode === 'watch') return;
      if (occupant && occupant.name !== onlineState.displayName) return;
      onlineState.seat = String(i);
      onlineState.ready = onlineState.role === 'host' ? true : false;
      updatePresence({ seat: onlineState.seat, ready: onlineState.ready });
      updateParticipantList();
    });
    ring.appendChild(seat);
  }
}

function updateParticipantList() {
  const list = getPresenceList();
  const activeList = list.filter(p => !isSpectator(p));
  const el = document.getElementById('participant-list');
  const summaryEl = document.getElementById('participant-summary');
  const roomCodeDisplay = document.getElementById('room-code-display');
  if (roomCodeDisplay) roomCodeDisplay.textContent = onlineState.roomCode || '‚Äî';
  if (el) {
    el.innerHTML = '';
    list.forEach(p => {
      const item = document.createElement('div');
      const isSelf = p.name === onlineState.displayName;
      item.className = 'participant-item' + (isSelf ? ' self' : '');
      const roleText = isSpectator(p) ? 'spectator' : (p.role || 'player');
      item.innerHTML = `
        <div>
          <div class="participant-name">${p.name || 'Guest'}${isSelf ? ' („ÅÇ„Å™„Åü)' : ''} ${p.seat ? `‚Ä¢ Seat ${p.seat}` : ''}</div>
          <div class="participant-meta">${p.online ? 'ONLINE' : 'OFFLINE'}</div>
        </div>
        <div>
          <div class="participant-role ${roleText}">${roleText}</div>
          <div class="participant-ready ${p.ready ? 'ready' : ''}">${p.ready ? 'READY' : 'NOT READY'}</div>
        </div>
      `;
      el.appendChild(item);
    });
  }
  if (summaryEl) {
    summaryEl.innerHTML = '';
    list.forEach(p => {
      const item = document.createElement('div');
      item.className = 'participant-item';
      const roleText = isSpectator(p) ? 'spectator' : (p.role || 'player');
      item.innerHTML = `
        <div class="participant-name">${p.name || 'Guest'} ${p.seat ? `‚Ä¢ Seat ${p.seat}` : ''}</div>
        <div class="participant-role ${roleText}">${roleText}</div>
      `;
      summaryEl.appendChild(item);
    });
  }

  const hostControls = document.getElementById('waiting-host-controls');
  const hostStatus = document.getElementById('waiting-host-status');
  const startBtn = document.getElementById('waiting-start-btn');
  const guestControls = document.getElementById('waiting-guest-controls');
  if (onlineState.role === 'host' && hostControls) {
    hostControls.style.display = 'block';
    const canStart = activeList.length >= 2 && activeList.every(p => p.role === 'host' ? !!p.seat : p.ready);
    if (startBtn) startBtn.disabled = !canStart;
    if (hostStatus) hostStatus.textContent = canStart ? 'ÂÖ®Âì°Ê∫ñÂÇôOK„ÄÇË®≠ÂÆö„Å∏ÈÄ≤„ÇÅ„Åæ„Åô' : 'ÂÖ®Âì°„ÅÆÊ∫ñÂÇôÂÆå‰∫Ü„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô';
    if (guestControls) guestControls.style.display = 'none';
  } else if (guestControls) {
    guestControls.style.display = 'block';
    if (hostControls) hostControls.style.display = 'none';
  }

  renderSeatRing(activeList);
  const readyBtn = document.getElementById('ready-toggle-btn');
  const seatHelp = document.getElementById('seat-help-text');
  const stepSeat = document.getElementById('step-seat');
  const stepReady = document.getElementById('step-ready');
  const seatConflict = activeList.some(p => p.seat && p.seat === onlineState.seat && p.name !== onlineState.displayName);
  if (seatConflict) {
    onlineState.seat = '';
    onlineState.ready = false;
    updatePresence({ seat: "", ready: false });
  }

  // Update step guide
  if (stepSeat && stepReady) {
    stepSeat.classList.remove('active', 'done');
    stepReady.classList.remove('active', 'done');
    const isSpectatorSelf = onlineState.joinMode === 'watch';
    stepReady.style.display = (onlineState.role === 'host' || isSpectatorSelf) ? 'none' : 'flex';
    if (!onlineState.seat) {
      stepSeat.classList.add('active');
    } else if (!(onlineState.role === 'host' ? !!onlineState.seat : onlineState.ready)) {
      stepSeat.classList.add('done');
      stepReady.classList.add('active');
    } else {
      stepSeat.classList.add('done');
      stepReady.classList.add('done');
    }
  }

  const effectiveReady = onlineState.role === 'host' ? !!onlineState.seat : onlineState.ready;
  if (readyBtn) {
    readyBtn.style.display = (onlineState.role === 'host' || onlineState.joinMode === 'watch') ? 'none' : 'inline-flex';
    readyBtn.classList.toggle('on', onlineState.ready);
    readyBtn.textContent = onlineState.ready ? '‚úì READY' : 'READY';
    readyBtn.disabled = !onlineState.seat;
  }
  if (seatHelp) {
    if (onlineState.joinMode === 'watch') {
      seatHelp.textContent = 'Ë¶≥Êà¶‰∏≠„Åß„Åô';
      return;
    }
    if (!onlineState.seat) {
      seatHelp.textContent = 'üëÜ „Åæ„ÅöÁ©∫Â∏≠„Çí„Çø„ÉÉ„Éó„Åó„Å¶„Å≠';
    } else if (!effectiveReady) {
      seatHelp.textContent = `Seat ${onlineState.seat} „ÇíÈÅ∏Êäû‰∏≠ ‚Üí READY„ÇíÊäº„Åù„ÅÜÔºÅ`;
    } else {
      seatHelp.textContent = onlineState.role === 'host'
        ? '‚úì „Éõ„Çπ„ÉàÊ∫ñÂÇôÂÆå‰∫Ü„ÄÇÂèÇÂä†ËÄÖ„ÅÆREADY„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô'
        : '‚úì Ê∫ñÂÇôÂÆå‰∫ÜÔºÅ„Éõ„Çπ„Éà„ÅÆÈñãÂßã„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô';
    }
  }
}

async function leaveRoom(options = {}) {
  if (roomChannel) {
    try { await roomChannel.untrack?.(); } catch (e) {}
    try { await roomChannel.unsubscribe(); } catch (e) {}
    roomChannel = null;
  }
  clearHostAbsentTimer();
  onlineState = {
    role: "local",
    roomCode: "",
    connected: false,
    displayName: onlineState.displayName,
    seat: "",
    ready: false,
    joinedAt: 0,
    joinMode: "play",
    requestedChips: 1000,
    joinConfirmed: false,
    rebuyRequested: false,
    away: false,
    pendingExit: false
  };
  joinChoiceConfirmed = false;
  gameState = null;
  stopTournamentTimer();
  stopActionTimer();
  onlineReady = false;
  setRoomControls(false);
  setRoomStatus('„É≠„Éº„Ç´„É´„É¢„Éº„Éâ');
  setUiState('room');
  updatePlayerBadge();
  if (options.clearReconnect) {
    clearReconnectInfo();
  }
}

async function createRoomWithUniqueCode(maxAttempts = 5) {
  initSupabase();
  if (!supabaseClient) return;

  for (let i = 0; i < maxAttempts; i++) {
    const code = generateRoomCode();
    const ok = await joinRoom("host", code, true);
    if (ok) {
      const input = document.getElementById('room-code-input');
      if (input) input.value = code;
      return true;
    }
  }
  setRoomStatus('„É´„Éº„É†‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
  return false;
}

async function joinRoom(role, code, isAuto = false) {
  initSupabase();
  if (!supabaseClient) return false;

  if (!onlineState.displayName) {
    if (!isAuto) setRoomStatus('ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
    return false;
  }

  const roomCode = normalizeRoomCode(code);
  if (!roomCode) {
    if (!isAuto) setRoomStatus('„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
    return false;
  }

  if (roomChannel) {
    await leaveRoom();
  }

  onlineState = {
    role,
    roomCode,
    connected: false,
    displayName: onlineState.displayName,
    seat: onlineState.seat,
    ready: onlineState.ready,
    joinedAt: onlineState.joinedAt,
    joinMode: role === 'host' ? 'play' : (onlineState.joinMode || 'play'),
    requestedChips: onlineState.requestedChips || 1000,
    joinConfirmed: role === 'host',
    rebuyRequested: false,
    away: false,
    pendingExit: false
  };
  joinChoiceConfirmed = onlineState.joinConfirmed;
  setRoomStatus(`Êé•Á∂ö‰∏≠: ${roomCode}`);

  const channelName = `room_${roomCode}`;
  roomChannel = supabaseClient.channel(channelName, {
    config: { presence: { key: `user_${Date.now()}_${Math.random().toString(16).slice(2)}` } }
  });

  roomChannel
    .on('presence', { event: 'sync' }, () => {
      const presenceState = roomChannel.presenceState();
      const list = Object.values(presenceState).flat();
      const hosts = list.filter(p => p.role === 'host');
      const nameDupes = list.filter(p => p.name === onlineState.displayName);
      if (nameDupes.length > 1) {
        leaveRoom();
        setRoomStatus('Âêå„ÅòÂêçÂâç„ÅÆÂèÇÂä†ËÄÖ„Åå„ÅÑ„Åæ„Åô');
        return;
      }
      if (list.length > 8 && onlineState.role !== 'host') {
        leaveRoom();
        setRoomStatus('Ê∫ÄÂ∏≠„Åß„Åô');
        return;
      }
      if (onlineState.role !== 'host' && hosts.length === 0 && onlineReady) {
        startHostAbsentTimer();
      } else {
        clearHostAbsentTimer();
      }
      if (onlineState.role === 'host') {
        // If another host already exists, back out and let caller retry
        if (hosts.length > 1) {
          leaveRoom();
          if (!isAuto) setRoomStatus('Êó¢„Å´„Éõ„Çπ„Éà„Åå„ÅÑ„Åæ„Åô');
          return;
        }
        onlineReady = true;
        setRoomStatus(`„Éõ„Çπ„Éà‰∏≠: ${roomCode}`);
        broadcastState();
        updateParticipantList();
      } else {
        onlineReady = true;
        setRoomStatus(`ÂèÇÂä†‰∏≠: ${roomCode}`);
        requestState();
        updateParticipantList();
      }
    })
    .on('presence', { event: 'join' }, () => {
      updateParticipantList();
    })
    .on('presence', { event: 'leave' }, () => {
      updateParticipantList();
    })
    .on('broadcast', { event: 'state-sync' }, payload => {
      if (onlineState.role === 'host') return;
      if (!payload?.payload?.state) return;
      gameState = payload.payload.state;
      if (payload?.payload?.chipsBeforeHand) {
        chipsBeforeHand = payload.payload.chipsBeforeHand;
      }
      localPendingActionKey = null;
      if (onlineState.role === 'player' && onlineState.joinMode === 'play' && onlineState.displayName) {
        const stillSeated = gameState.players.some(p => p.name === onlineState.displayName);
        if (!stillSeated) {
          onlineState.joinMode = 'watch';
          onlineState.ready = false;
          onlineState.seat = '';
          onlineState.pendingExit = false;
          onlineState.away = false;
          updatePresence({
            joinMode: onlineState.joinMode,
            ready: onlineState.ready,
            seat: onlineState.seat,
            pendingExit: onlineState.pendingExit,
            away: onlineState.away
          });
          updateJoinMenuVisibility();
          updateJoinStatusBanner();
          updateAwayControls();
          showToast('Ê¨°„ÅÆ„Éè„É≥„Éâ„Åã„ÇâÈÄÄÂá∫„Åó„Åæ„Åó„ÅüÔºàË¶≥Êà¶‰∏≠Ôºâ', 'info');
        }
      }
      if (gameState?.isHandActive && onlineState.role === 'player' && !joinChoiceConfirmed) {
        autoEnterOnStateSync = true;
        applyJoinMode('play', getAutoJoinChips());
      }
      if (autoEnterOnStateSync && gameState?.isHandActive) {
        autoEnterOnStateSync = false;
        setUiState('playing');
      }
      if (onlineState.role === 'player' && onlineState.rebuyRequested) {
        const selfPlayer = getSelfPlayer();
        if (selfPlayer && selfPlayer.chips > 0) {
          onlineState.rebuyRequested = false;
          updatePresence({ rebuyRequested: false });
        }
      }
      if (gameState?.isHandActive) {
        document.getElementById('next-hand-overlay').classList.remove('visible');
      }
      render();
      if (gameState.isHandActive) startActionTimer();
    })
    .on('broadcast', { event: 'ui-phase' }, payload => {
      const phase = payload?.payload?.phase;
      if (!phase) return;
      setUiState(phase);
      if (phase === 'settings') updateParticipantList();
    })
    .on('broadcast', { event: 'start-game' }, payload => {
      if (onlineState.role === 'host') return;
      const settings = payload?.payload?.settings;
      const state = payload?.payload?.state;
      if (settings) applySettings(settings);
      if (state) gameState = state;
      setUiState('playing');
      const tournamentBar = document.getElementById('tournament-bar');
      if (tournamentSettings.enabled) {
        tournamentBar.style.display = 'flex';
        tournamentTimeRemaining = tournamentSettings.levelDuration * 60;
        updateTournamentDisplay();
      } else {
        tournamentBar.style.display = 'none';
      }
      render();
      if (gameState?.isHandActive) startActionTimer();
    })
    .on('broadcast', { event: 'state-request' }, () => {
      if (onlineState.role === 'host') broadcastState();
    })
    .on('broadcast', { event: 'action-request' }, payload => {
      if (onlineState.role !== 'host') return;
      const { type, amount } = payload?.payload || {};
      if (!type) return;
      applyRemoteAction(type, amount || 0);
    })
    .on('broadcast', { event: 'sound-toggle' }, payload => {
      if (onlineState.role === 'host') return;
      const enabled = payload?.payload?.enabled;
      if (typeof enabled === 'boolean') {
        setSoundEnabled(enabled);
      }
    })
    .on('broadcast', { event: 'showdown-resolved' }, payload => {
      if (onlineState.role === 'host') return;
      const winnerIds = payload?.payload?.winnerIds || [];
      if (!gameState || winnerIds.length === 0) return;
      const totalPot = getPotTotal(gameState);
      const per = Math.floor(totalPot / winnerIds.length);
      const rem = totalPot - per * winnerIds.length;
      const winners = winnerIds.map(id => {
        const p = gameState.players.find(pl => pl.id === id);
        return { name: p?.name || '‚Äî', icon: p?.icon || '' };
      });
      gameState = distributePot(gameState, winnerIds);
      render();
      setWinnerHighlight(winnerIds);
      animatePotToWinners(winnerIds);
      playWinChime();
      // ÂãùËÄÖ„ÅÆÂÆüÈöõ„ÅÆÊêçÁõä„ÇíË®àÁÆó
      const winnerGains = winnerIds.map(id => {
        const p = gameState.players.find(pl => pl.id === id);
        const before = chipsBeforeHand[id] || p.chips;
        return p.chips - before;
      });
      let gainText = '';
      if (winnerIds.length === 1) {
        const gain = winnerGains[0];
        gainText = `${gain >= 0 ? '+' : ''}${gain.toLocaleString()} „ÉÅ„ÉÉ„Éó`;
      } else {
        const totalGain = winnerGains.reduce((a, b) => a + b, 0);
        gainText = `ÂêàË®à ${totalGain >= 0 ? '+' : ''}${totalGain.toLocaleString()} „ÉÅ„ÉÉ„Éó`;
      }
      setTimeout(() => showNextHand(winners, gainText), 220);
    })
    .on('broadcast', { event: 'next-hand-request' }, () => {
      if (onlineState.role !== 'host') return;
      advanceToNextHandAndBroadcast();
    })
    .subscribe(async status => {
      if (status === 'SUBSCRIBED') {
        updatePresence({ joinedAt: Date.now() });
        onlineState.connected = true;
        setRoomControls(true);
        updateParticipantList();
        hideDisconnectDialog();
        setRoomStatus(`${onlineState.role === 'host' ? '„Éõ„Çπ„Éà‰∏≠' : 'ÂèÇÂä†‰∏≠'}: ${onlineState.roomCode}`);
        saveReconnectInfo({
          roomCode: onlineState.roomCode,
          role: onlineState.role,
          displayName: onlineState.displayName,
          joinMode: onlineState.joinMode || 'play',
          requestedChips: onlineState.requestedChips || 1000,
          wasPlaying: uiState === 'playing'
        });
      }
      if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
        onlineState.connected = false;
        setRoomStatus('ÂÜçÊé•Á∂ö‰∏≠...');
        showDisconnectDialog();
        scheduleReconnect();
      }
      if (status === 'CLOSED') {
        onlineState.connected = false;
        setRoomStatus('Êé•Á∂ö„ÅåÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü');
      }
    });

  return true;
}

function requestState() {
  if (!roomChannel) return;
  roomChannel.send({ type: 'broadcast', event: 'state-request', payload: {} });
}

function broadcastState() {
  if (!roomChannel || onlineState.role !== 'host') return;
  if (!gameState) return;
  roomChannel.send({ type: 'broadcast', event: 'state-sync', payload: { state: gameState, chipsBeforeHand } });
}

function sendActionRequest(type, amount) {
  if (!roomChannel) return;
  roomChannel.send({ type: 'broadcast', event: 'action-request', payload: { type, amount } });
}

function applyRemoteAction(type, amount) {
  const prevState = gameState;
  const result = processAction(gameState, type, amount);
  if (result.error) { console.warn(result.error); actionLock = false; return; }
  gameState = result;
  if (hasNewAllIn(prevState, gameState)) playAllInHit();
  render();
  if (gameState.isHandActive) {
    startActionTimer();
  }
  broadcastState();
}

// ‚îÄ‚îÄ‚îÄ TIMER FUNCTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startActionTimer() {
  stopActionTimer();
  if (timerSettings.duration === 0) return; // ÁÑ°Âà∂Èôê
  if (onlineState.joinMode === 'watch') return;
  if (onlineState.role === 'player') {
    if (!gameState) return;
    const actor = gameState.players[gameState.currentPlayerIndex];
    if (!actor || actor.name !== onlineState.displayName) return;
  }

  timeRemaining = timerSettings.duration;
  timerStartTime = Date.now();
  updateTimerDisplay();

  actionTimer = setInterval(() => {
    const elapsed = (Date.now() - timerStartTime) / 1000;
    timeRemaining = Math.max(0, timerSettings.duration - elapsed);

    updateTimerDisplay();

    // ÊÆã„Çä5Áßí„ÅßË≠¶ÂëäÈü≥
    if (timerSettings.soundEnabled && Math.ceil(timeRemaining) === 5) {
      playTimerWarning();
    }

    if (timeRemaining <= 0) {
      handleTimeOut();
    }
  }, 100);
}

function stopActionTimer() {
  if (actionTimer) {
    clearInterval(actionTimer);
    actionTimer = null;
  }
  timeRemaining = 0;
}

function updateTimerDisplay() {
  const ring = document.querySelector('.player-card.is-actor .timer-ring .progress');
  const text = document.querySelector('.player-card.is-actor .timer-text');
  if (!ring || !text) return;

  const pct = timerSettings.duration > 0 ? timeRemaining / timerSettings.duration : 1;
  const circumference = 2 * Math.PI * 28;
  ring.style.strokeDashoffset = circumference * (1 - pct);

  const secs = Math.ceil(timeRemaining);
  text.textContent = `0:${secs.toString().padStart(2, '0')}`;

  // Color states
  ring.classList.remove('warning', 'danger');
  text.classList.remove('warning', 'danger');
  if (secs <= 5) {
    ring.classList.add('danger');
    text.classList.add('danger');
  } else if (secs <= 10) {
    ring.classList.add('warning');
    text.classList.add('warning');
  }
  updateJoinStatusBanner();
}

function handleTimeOut() {
  stopActionTimer();
  if (!gameState || !gameState.isHandActive) return;

  const actor = gameState.players[gameState.currentPlayerIndex];
  if (actor.status !== 'active') return;

  // Play timeout sound
  if (timerSettings.soundEnabled) playTimeoutSound();

  // Auto action: check if possible, otherwise fold
  const callAmt = gameState.currentMaxBet - actor.currentBet;
  if (callAmt === 0) {
    doAction('check');
  } else {
    doAction('fold');
  }
}

function playTimerWarning() {
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.frequency.value = 880;
    gain.gain.value = 0.1;
    osc.start();
    osc.stop(ctx.currentTime + 0.1);
  } catch (e) {}
}

function playTimeoutSound() {
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.frequency.value = 440;
    gain.gain.value = 0.15;
    osc.start();
    osc.stop(ctx.currentTime + 0.3);
  } catch (e) {}
}

// ‚îÄ‚îÄ‚îÄ TOURNAMENT FUNCTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startTournamentTimer() {
  stopTournamentTimer();
  if (!tournamentSettings.enabled) return;
  if (onlineState.role === 'player') return;

  tournamentTimeRemaining = tournamentSettings.levelDuration * 60;
  updateTournamentDisplay();

  tournamentTimer = setInterval(() => {
    tournamentTimeRemaining--;
    updateTournamentDisplay();

    if (tournamentTimeRemaining <= 0) {
      advanceBlindLevel();
    }
  }, 1000);
}

function stopTournamentTimer() {
  if (tournamentTimer) {
    clearInterval(tournamentTimer);
    tournamentTimer = null;
  }
}

function updateTournamentDisplay() {
  const bar = document.getElementById('tournament-bar');
  if (!bar || !tournamentSettings.enabled) return;

  const mins = Math.floor(tournamentTimeRemaining / 60);
  const secs = tournamentTimeRemaining % 60;

  bar.querySelector('.next-level span').textContent =
    `${mins}:${secs.toString().padStart(2, '0')}`;
  bar.querySelector('.level').textContent = `Level ${currentBlindLevel}`;
  bar.querySelector('.blinds').textContent =
    `${gameState.smallBlind} / ${gameState.bigBlind}`;
}

function advanceBlindLevel() {
  if (!gameState) return;
  currentBlindLevel++;
  gameState.smallBlind *= 2;
  gameState.bigBlind *= 2;
  tournamentTimeRemaining = tournamentSettings.levelDuration * 60;
  updateTournamentDisplay();
  if (onlineState.role === 'host') {
    broadcastState();
  }

  // Play level up sound
  if (timerSettings.soundEnabled) {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.frequency.value = 660;
      gain.gain.value = 0.15;
      osc.start();
      setTimeout(() => { osc.frequency.value = 880; }, 150);
      osc.stop(ctx.currentTime + 0.3);
    } catch (e) {}
  }
}

function collectSettingsFromForm() {
  return {
    smallBlind: parseInt(document.getElementById('sb-input').value) || 10,
    bigBlind: parseInt(document.getElementById('bb-input').value) || 20,
    initialChips: parseInt(document.getElementById('initial-chips-input').value) || 1000,
    timerDuration: parseInt(document.getElementById('timer-select').value) || 0,
    soundEnabled: document.getElementById('timer-sound-toggle').checked,
    tournamentEnabled: document.getElementById('tournament-mode-toggle').checked,
    levelDuration: parseInt(document.getElementById('blind-level-select').value) || 15,
    lateJoinEnabled: document.getElementById('late-join-toggle')?.checked ?? true,
    lateJoinMaxChips: parseInt(document.getElementById('late-join-max-chips')?.value || '0', 10) || 1000
  };
}

function applySettings(settings) {
  timerSettings.duration = settings.timerDuration;
  timerSettings.soundEnabled = settings.soundEnabled;
  tournamentSettings.enabled = settings.tournamentEnabled;
  tournamentSettings.levelDuration = settings.levelDuration;
  lateJoinSettings.enabled = !!settings.lateJoinEnabled;
  lateJoinSettings.maxChips = settings.lateJoinMaxChips || 1000;
  currentBlindLevel = 1;
  updateSoundMenuLabel();
}

function updateSoundMenuLabel() {
  const btn = document.getElementById('menu-sound-toggle');
  if (!btn) return;
  btn.textContent = `Èü≥Èáè: ${timerSettings.soundEnabled ? 'ON' : 'OFF'}`;
}

function setSoundEnabled(enabled, persist = true) {
  timerSettings.soundEnabled = !!enabled;
  const toggle = document.getElementById('timer-sound-toggle');
  if (toggle) toggle.checked = timerSettings.soundEnabled;
  updateSoundMenuLabel();
  if (persist) {
    try {
      localStorage.setItem(SOUND_STORAGE_KEY, timerSettings.soundEnabled ? '1' : '0');
    } catch (e) {}
  }
}

function updateJoinStatusMenuLabel() {
  const btn = document.getElementById('menu-join-status');
  if (!btn) return;
  if (onlineState.role !== 'player') {
    btn.style.display = 'none';
    return;
  }
  let status = 'Ë¶≥Êà¶';
  if (onlineState.joinMode === 'play') {
    status = isSelfInGame() ? 'ÂèÇÂä†‰∏≠' : 'ÂæÖÊ©ü';
  }
  btn.style.display = 'inline-flex';
  btn.textContent = `ÂèÇÂä†Áä∂ÊÖã: ${status}`;
}

function canLateJoin() {
  const settings = gameState?.lateJoinSettings || lateJoinSettings;
  return !!settings?.enabled;
}

function getLocalPlayers() {
  const rows = document.querySelectorAll('.player-row');
  const players = [];
  rows.forEach((row, i) => {
    const input = row.querySelector('.player-name-input');
    const name = input ? input.value.trim() : '';
    const icon = row.dataset.icon || '';
    if (!name && !icon) return;
    const finalName = name || icon || `„Éó„É¨„Ç§„É§„Éº${i + 1}`;
    players.push({ name: finalName, icon });
  });
  return players;
}

function getLocalPlayerFormData() {
  const rows = document.querySelectorAll('.player-row');
  const data = [];
  rows.forEach(row => {
    const input = row.querySelector('.player-name-input');
    const name = input ? input.value.trim() : '';
    const icon = row.dataset.icon || '';
    if (!name && !icon) return;
    data.push({ name, icon });
  });
  return data;
}

function getOnlinePlayerNames() {
  const list = getPresenceList();
  return list.map((p, i) => p.name || `Player ${i + 1}`);
}

function getOnlinePlayers() {
  const list = getPresenceList().filter(p => !isSpectator(p));
  return list.map((p, i) => ({ name: p.name || `Player ${i + 1}`, icon: '' }));
}

function getPerPlayerStackEnabled() {
  const toggle = document.getElementById('per-player-stack-toggle');
  return !!toggle && toggle.checked;
}

function getPerPlayerStackInputs() {
  return Array.from(document.querySelectorAll('.stack-row input[data-index]'));
}

function renderPerPlayerStackList() {
  const listEl = document.getElementById('per-player-stack-list');
  if (!listEl) return;
  const enabled = getPerPlayerStackEnabled();
  listEl.style.display = enabled ? 'flex' : 'none';
  const initialChipsRow = document.getElementById('initial-chips-row');
  if (initialChipsRow) {
    initialChipsRow.style.display = enabled ? 'none' : 'flex';
  }
  if (!enabled) return;

  const settings = collectSettingsFromForm();
  const players = onlineState.role === 'host' ? getOnlinePlayers() : getLocalPlayers();
  listEl.innerHTML = '';
  const defaultChips = settings.initialChips;

  players.forEach((p, i) => {
    const row = document.createElement('div');
    row.className = 'stack-row';
    const input = document.createElement('input');
    input.type = 'number';
    input.min = '1';
    input.step = '1';
    input.inputMode = 'numeric';
    input.className = 'stack-input';
    input.dataset.index = String(i);
    const saved = perPlayerStackChips[i];
    input.value = String(saved || defaultChips);

    const bbDisplay = document.createElement('div');
    bbDisplay.className = 'stack-meta';
    const updateBBDisplay = () => {
      const chips = parseInt(input.value, 10);
      const validChips = Number.isFinite(chips) && chips >= 1 ? chips : defaultChips;
      const bb = settings.bigBlind > 0 ? Math.floor(validChips / settings.bigBlind) : 0;
      bbDisplay.textContent = `= ${bb.toLocaleString()} BB`;
      perPlayerStackChips[i] = validChips;
    };
    updateBBDisplay();
    input.addEventListener('input', updateBBDisplay);

    row.innerHTML = `<div class="stack-name">${p.name}</div>`;
    row.appendChild(input);
    row.appendChild(bbDisplay);
    listEl.appendChild(row);
  });
}

function updatePerPlayerBBDisplays() {
  const settings = collectSettingsFromForm();
  const rows = document.querySelectorAll('.stack-row');
  rows.forEach(row => {
    const input = row.querySelector('.stack-input');
    const bbDisplay = row.querySelector('.stack-meta');
    if (!input || !bbDisplay) return;
    const chips = parseInt(input.value, 10);
    const validChips = Number.isFinite(chips) && chips >= 1 ? chips : settings.initialChips;
    const bb = settings.bigBlind > 0 ? Math.floor(validChips / settings.bigBlind) : 0;
    bbDisplay.textContent = `= ${bb.toLocaleString()} BB`;
  });
}

function startGameWithPlayers(players, settings) {
  applySettings(settings);
  const perPlayerEnabled = getPerPlayerStackEnabled();
  const stackInputs = getPerPlayerStackInputs();
  const stacksByIndex = new Map();
  if (perPlayerEnabled) {
    stackInputs.forEach(input => {
      const idx = parseInt(input.dataset.index || '0', 10);
      const chips = parseInt(input.value, 10);
      const validChips = Number.isFinite(chips) && chips >= 1 ? chips : settings.initialChips;
      stacksByIndex.set(idx, validChips);
    });
  }
  const playersWithStacks = players.map((p, i) => ({
    ...p,
    startingChips: perPlayerEnabled ? (stacksByIndex.get(i) || settings.initialChips) : settings.initialChips
  }));
  gameState = initGame(playersWithStacks, settings.smallBlind, settings.bigBlind, settings.initialChips);
  gameState.timerSettings = { ...timerSettings };
  gameState.tournamentSettings = { ...tournamentSettings };
  gameState.lateJoinSettings = { ...lateJoinSettings };
  handHistory = [];
  saveChipsBeforeHand();  // SB/BBÊâï„ÅÜÂâç„Å´Ë®òÈå≤
  gameState = startHand(gameState);

  setUiState('playing');

  const tournamentBar = document.getElementById('tournament-bar');
  if (tournamentSettings.enabled) {
    tournamentBar.style.display = 'flex';
    startTournamentTimer();
  } else {
    tournamentBar.style.display = 'none';
  }

  render();
  startActionTimer();
}

function updateSettingsPanels() {
  const hostPanel = document.getElementById('settings-host-panel');
  const guestPanel = document.getElementById('settings-guest-panel');
  const onlineSummary = document.getElementById('online-player-summary');
  const localSettings = document.getElementById('local-player-settings');
  const guestSummary = document.getElementById('guest-participant-summary');

  if (onlineState.role === 'player') {
    if (hostPanel) hostPanel.style.display = 'none';
    if (guestPanel) guestPanel.style.display = 'block';
    // „Ç≤„Çπ„ÉàÁî®„Å´ÂèÇÂä†ËÄÖ„É™„Çπ„Éà„ÇíË°®Á§∫
    if (guestSummary) {
      const list = getPresenceList();
      guestSummary.innerHTML = '';
      list.forEach(p => {
        const item = document.createElement('div');
        const isSelf = p.name === onlineState.displayName;
        const roleText = isSpectator(p) ? 'spectator' : (p.role || 'player');
        item.className = 'participant-item' + (isSelf ? ' self' : '');
        item.innerHTML = `
          <div class="participant-name">${p.name || 'Guest'}${isSelf ? ' („ÅÇ„Å™„Åü)' : ''}</div>
          <div class="participant-role ${roleText}">${roleText}</div>
        `;
        guestSummary.appendChild(item);
      });
    }
  } else {
    if (hostPanel) hostPanel.style.display = 'block';
    if (guestPanel) guestPanel.style.display = 'none';
  }
  if (onlineSummary && localSettings) {
    const isOnlineHost = onlineState.role === 'host';
    onlineSummary.style.display = isOnlineHost ? 'block' : 'none';
    localSettings.style.display = isOnlineHost ? 'none' : 'block';
  }
  updateInitialChipsBB();
  renderPerPlayerStackList();
}

// Player positions (ellipse ring). index ‚Üí {x%, y%}
function calcPositions(n) {
  const positions = [];
  const cx = 50, cy = 50;

  // 2‰∫∫„ÅÆÂ†¥Âêà: ‰∏ä‰∏ã„Å´Â§ß„Åç„ÅèÈõ¢„Åô
  if (n === 2) {
    positions.push({ x: cx, y: 10 });  // ‰∏ä
    positions.push({ x: cx, y: 90 });  // ‰∏ã
    return positions;
  }

  // 3-4‰∫∫„ÅÆÂ†¥Âêà: Â∫É„ÇÅ„ÅÆÊ•ïÂÜÜ
  if (n <= 4) {
    const rx = 44, ry = 42;
    for (let i = 0; i < n; i++) {
      const angle = (i / n) * 2 * Math.PI - Math.PI / 2;
      positions.push({
        x: cx + rx * Math.cos(angle),
        y: cy + ry * Math.sin(angle)
      });
    }
    return positions;
  }

  // 5‰∫∫‰ª•‰∏ä: Ê®ôÊ∫ñ„ÅÆÊ•ïÂÜÜÈÖçÁΩÆ
  const rx = 42, ry = 40;
  for (let i = 0; i < n; i++) {
    const angle = (i / n) * 2 * Math.PI - Math.PI / 2;
    positions.push({
      x: cx + rx * Math.cos(angle),
      y: cy + ry * Math.sin(angle)
    });
  }
  return positions;
}

function renderPlayers() {
  const ring = document.getElementById('players-ring');
  ring.innerHTML = '';
  if (!gameState) return;

  const positions = calcPositions(gameState.players.length);

  gameState.players.forEach((player, idx) => {
    const pos = positions[idx];
    const isActor = idx === gameState.currentPlayerIndex && gameState.isHandActive && player.status === "active";
    const isDealer = idx === gameState.dealerIndex;
    const isFolded = player.status === "folded";
    const isAllIn = player.status === "allIn";
    const isWinner = winnerHighlightIds.includes(player.id);

    let classes = 'player-card';
    if (isActor) classes += ' is-actor';
    if (isFolded) classes += ' folded';
    if (isAllIn) classes += ' allin';
    if (isWinner) classes += ' is-winner';
    if (idx === 0) classes += ' seat-top';

    const initial = player.name ? player.name.charAt(0).toUpperCase() : '';
    const avatarSymbol = player.icon || initial || '?';
    const showName = player.name && player.name !== player.icon;
    const hasBet = player.currentBet > 0;

    const card = document.createElement('div');
    card.className = classes;
    card.dataset.playerId = player.id;
    card.style.left = pos.x + '%';
    card.style.top = pos.y + '%';

    // Timer ring for active player (only if timer is enabled)
    const showTimer = isActor && timerSettings.duration > 0;
    const circumference = 2 * Math.PI * 28;
    const timerRingHtml = showTimer ? `
      <svg class="timer-ring" width="64" height="64" viewBox="0 0 64 64">
        <circle class="bg" cx="32" cy="32" r="28"/>
        <circle class="progress" cx="32" cy="32" r="28"
          style="stroke-dasharray: ${circumference}; stroke-dashoffset: 0"/>
      </svg>
      <div class="timer-text">0:${timerSettings.duration.toString().padStart(2, '0')}</div>
    ` : '';

    card.innerHTML = `
      <div class="allin-badge">ALL IN</div>
      <div class="avatar">
        ${timerRingHtml}
        ${isDealer ? '<div class="dealer-badge">D</div>' : ''}
        ${avatarSymbol}
        ${hasBet ? `<div class="bet-badge">${formatAmount(player.currentBet)}</div>` : ''}
      </div>
      <div class="info-line">
        <div class="name${showName ? '' : ' is-empty'}">${showName ? player.name : ''}</div>
        <div class="chips">${formatAmount(player.chips)}</div>
      </div>
    `;
    ring.appendChild(card);

    // Bet badge visibility
    if (hasBet) {
      setTimeout(() => {
        const badge = card.querySelector('.bet-badge');
        if (badge) {
          const dx = 50 - pos.x;
          const dy = 50 - pos.y;
          const mag = Math.hypot(dx, dy) || 1;
          const offset = 26;
          const ox = (dx / mag) * offset;
          const oy = (dy / mag) * offset;
          badge.style.opacity = '1';
          badge.style.transform = `translate(-50%, -50%) translate(${ox}px, ${oy}px)`;
        }
      }, 50);
    }
  });
}

function setWinnerHighlight(ids) {
  winnerHighlightIds = Array.isArray(ids) ? ids.slice() : [];
  if (winnerHighlightTimer) clearTimeout(winnerHighlightTimer);
  renderPlayers();
  winnerHighlightTimer = setTimeout(() => {
    winnerHighlightIds = [];
    renderPlayers();
  }, 3600);
}

function animatePotToWinners(winnerIds) {
  const pot = document.querySelector('.pot-center');
  if (!pot || !winnerIds || winnerIds.length === 0) return;
  const potRect = pot.getBoundingClientRect();
  const startX = potRect.left + potRect.width / 2;
  const startY = potRect.top + potRect.height / 2;
  const targets = winnerIds
    .map(id => document.querySelector(`.player-card[data-player-id="${id}"] .avatar`))
    .filter(Boolean)
    .slice(0, 3);
  if (targets.length === 0) return;

  targets.forEach((avatar, i) => {
    const rect = avatar.getBoundingClientRect();
    const endX = rect.left + rect.width / 2;
    const endY = rect.top + rect.height / 2;
    const flyer = document.createElement('div');
    flyer.className = 'pot-flyer';
    flyer.style.left = `${startX}px`;
    flyer.style.top = `${startY}px`;
    flyer.style.transform = 'translate(-50%, -50%)';
    flyer.style.opacity = '1';
    document.body.appendChild(flyer);
    const dx = endX - startX;
    const dy = endY - startY;
    setTimeout(() => {
      flyer.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(0.4)`;
      flyer.style.opacity = '0';
    }, 40 + i * 40);
    flyer.addEventListener('transitionend', () => flyer.remove(), { once: true });
  });
}

function renderPot() {
  const total = (gameState.pots||[]).reduce((s, p) => s + p.amount, 0);
  const el = document.getElementById('pot-amount');
  const prev = parseInt(el.dataset.value || '0', 10) || 0;
  el.dataset.value = String(total);
  el.textContent = formatAmount(total);
  if (total !== prev && total > 0) {
    el.classList.remove('bump');
    void el.offsetWidth; // reflow
    el.classList.add('bump');
  }
}

function getCommunityCardCount(phase) {
  switch (phase) {
    case 'flop': return 3;
    case 'turn': return 4;
    case 'river': return 5;
    case 'showdown': return 5;
    default: return 0;
  }
}

function renderCommunityCards() {
  const container = document.getElementById('community-cards');
  if (!container) return;
  container.innerHTML = '';
  const count = gameState ? getCommunityCardCount(gameState.phase) : 0;
  const prevCount = lastCommunityCount;
  for (let i = 0; i < 5; i++) {
    const slot = document.createElement('div');
    slot.className = 'community-slot';
    if (i < count) {
      if (i >= prevCount) slot.classList.add('revealed');
      const img = document.createElement('img');
      img.src = 'img/trump.png';
      img.alt = '';
      img.loading = 'lazy';
      img.onerror = () => { img.style.display = 'none'; };
      slot.appendChild(img);
    } else {
      slot.classList.add('empty');
    }
    container.appendChild(slot);
  }
  lastCommunityCount = count;
}

function renderPhase() {
  const phase = gameState ? gameState.phase : 'preflop';
  const phaseLabel = document.getElementById('phase-label');
  if (phaseLabel) phaseLabel.textContent = phase.toUpperCase();

  const order = ['preflop','flop','turn','river'];
  const currentIdx = order.indexOf(phase);
  document.querySelectorAll('.phase-step').forEach((el, i) => {
    el.classList.remove('active','completed');
    if (i < currentIdx) el.classList.add('completed');
    else if (i === currentIdx) el.classList.add('active');
  });

  if (lastPhaseFx && lastPhaseFx !== phase) {
    triggerPhasePulse();
    playPhaseChime();
  }
  lastPhaseFx = phase;
}

function renderActionPanel() {
  const panel = document.getElementById('action-panel');
  const btnsEl = document.getElementById('action-btns');
  const lockMessage = document.getElementById('action-lock-message');
  const actorLabel = document.getElementById('actor-label');
  btnsEl.innerHTML = '';
  updateAwayControls();

  if (!gameState || !gameState.isHandActive) {
    panel.classList.add('hidden');
    return;
  }

  const actorIdx = gameState.currentPlayerIndex;
  const actor = gameState.players[actorIdx];
  const turnKey = `${actor.id}:${gameState.currentMaxBet}:${gameState.phase}`;
  if (turnKey !== lastTurnKey) {
    lastTurnKey = turnKey;
    lastActionId = null;
    autoFoldTurnKey = null;
  }
  const isMyTurn = onlineState.joinMode !== 'watch' &&
    (onlineState.role === 'local' || actor.name === onlineState.displayName);
  const hasPending = localPendingActionKey === turnKey;

  // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Éó„É¨„Ç§„É§„Éº„Åå„ÅÑ„Å™„ÅÑÂ†¥ÂêàÔºàÂÖ®Âì°„Ç™„Éº„É´„Ç§„É≥„Åæ„Åü„ÅØ„Éï„Ç©„Éº„É´„ÉâÔºâ
  if (actor.status !== 'active') {
    panel.classList.remove('hidden');
    panel.classList.add('locked');
    if (actorLabel) actorLabel.innerHTML = 'Ê¨°„ÅÆ„Éï„Çß„Éº„Ç∫„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...';
    if (lockMessage) lockMessage.style.display = 'none';
    return;
  }

  if (onlineState.role === 'host' && isPlayerAway(actor.name)) {
    if (autoFoldTurnKey !== turnKey) {
      autoFoldTurnKey = turnKey;
      setTimeout(() => { doAction('fold'); }, 100);
    }
  }

  panel.classList.remove('hidden');
  panel.classList.remove('locked');
  if (lockMessage) lockMessage.style.display = 'none';

  // Actor label
  if (actorLabel) actorLabel.innerHTML = `<strong>${actor.name}</strong> „ÅÆ„Çø„Éº„É≥„Åß„Åô`;

  if (!isMyTurn || hasPending) {
    panel.classList.add('locked');
    if (lockMessage) {
      lockMessage.style.display = 'block';
      lockMessage.innerHTML = onlineState.joinMode === 'watch'
        ? 'Ë¶≥Êà¶‰∏≠„Åß„ÅôÔºàÂèÇÂä†„ÅØ„É°„Éã„É•„Éº„Åã„ÇâÔºâ'
        : '„ÅÇ„Å™„Åü„ÅÆÁï™„Å´„Å™„Çã„Åæ„Åß„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ';
    }
    return;
  }

  const callAmt = gameState.currentMaxBet - actor.currentBet;
  const canCheck = callAmt === 0;

  // Fold
  btnsEl.appendChild(makeActionBtn('btn-fold', 'FOLD', '‚Äî', () => handleFoldAttempt()));

  // Check or Call
  if (canCheck) {
    btnsEl.appendChild(makeActionBtn('btn-check', 'CHECK', formatAmount(0), () => doAction('check')));
  } else {
    const actualCall = Math.min(callAmt, actor.chips);
    const isAllInCall = actualCall >= actor.chips;
    btnsEl.appendChild(makeActionBtn('btn-call', 'CALL', isAllInCall ? 'ALL IN' : formatAmount(actualCall), () => doAction('call')));
  }

  // Raise (only if chips remain after a potential call)
  const minRaise = gameState.currentMaxBet + gameState.lastRaiseSize;
  const maxRaise = actor.chips + actor.currentBet;
  if (maxRaise >= minRaise) {
    setRaiseValue(minRaise);
    btnsEl.appendChild(makeActionBtn('btn-raise', 'RAISE', formatAmount(raiseValue), () => toggleRaiseArea()));
    setupRaiseSlider(minRaise, maxRaise);
  }

  // Hide raise area initially
  document.getElementById('raise-area').classList.remove('visible');
}

let actionProcessing = false;
function makeActionBtn(cls, label, sub, onClick) {
  const btn = document.createElement('button');
  btn.className = 'action-btn ' + cls;
  btn.innerHTML = `<span class="btn-label">${label}</span><span class="btn-sub">${sub}</span>`;

  // „Éá„Éê„Ç¶„É≥„ÇπÂá¶ÁêÜ„Åß‰∫åÈáçÁô∫ÁÅ´Èò≤Ê≠¢
  const handleClick = (e) => {
    e.preventDefault();
    if (actionProcessing) return;
    actionProcessing = true;
    setTimeout(() => { actionProcessing = false; }, 300);
    onClick();
  };

  btn.addEventListener('click', handleClick);
  btn.addEventListener('touchend', (e) => {
    e.preventDefault();
    handleClick(e);
  });
  return btn;
}

let raiseMin = 0, raiseMax = 0;
let raiseMinTo = 0;
let actionLock = false;
let lastActionId = null;
let lastTurnKey = null;
let localPendingActionKey = null;
let autoFoldTurnKey = null;
function setupRaiseSlider(min, max) {
  raiseMin = min;
  raiseMax = max;
  raiseMinTo = min;
  const slider = document.getElementById('raise-slider');
  slider.min = 0;
  slider.max = 100;
  slider.value = 0; // min position
  setRaiseValue(min);
  updateRaisePresets();
  updateRaiseMinLabel();
}

function setRaiseValue(value) {
  const clamped = Math.max(raiseMin, Math.min(raiseMax, Math.round(value)));
  raiseValue = clamped;
  const display = document.getElementById('raise-amount-display');
  if (display) setTextWithBump(display, formatAmount(raiseValue));
  const slider = document.getElementById('raise-slider');
  if (slider && raiseMax > raiseMin) {
    const pct = (raiseValue - raiseMin) / (raiseMax - raiseMin);
    slider.value = Math.round(pct * 100);
  }
  const raiseBtn = document.querySelector('.btn-raise .btn-sub');
  if (raiseBtn) setTextWithBump(raiseBtn, formatAmount(raiseValue));
  updateActivePreset();
  updateRaiseMinLabel();
  updateRaiseError();
}

function onRaiseSlide() {
  const slider = document.getElementById('raise-slider');
  const pct = parseInt(slider.value) / 100;
  setRaiseValue(Math.round(raiseMin + (raiseMax - raiseMin) * pct));
}

function updateRaisePresets() {
  const presetsEl = document.getElementById('raise-presets');
  if (!presetsEl || !gameState) return;
  presetsEl.innerHTML = '';
  const actor = gameState.players[gameState.currentPlayerIndex];
  const callAmt = gameState.currentMaxBet - actor.currentBet;
  const totalPot = getPotTotal(gameState);

  const addPreset = (label, targetValue, extraClass = '') => {
    const value = Math.max(raiseMin, Math.min(raiseMax, Math.round(targetValue)));
    const btn = document.createElement('button');
    btn.className = `raise-preset-btn${extraClass ? ' ' + extraClass : ''}`;
    btn.textContent = label;
    btn.dataset.amount = String(value);
    btn.addEventListener('click', () => setRaiseValue(value), { passive: true });
    presetsEl.appendChild(btn);
  };

  if (gameState.phase === 'preflop') {
    addPreset('2.5BB', gameState.bigBlind * 2.5);
    addPreset('3BB', gameState.bigBlind * 3);
    addPreset('5BB', gameState.bigBlind * 5);
  } else {
    const potFractions = [
      ['1/3 POT', 1 / 3],
      ['1/2 POT', 1 / 2],
      ['2/3 POT', 2 / 3],
      ['FULL POT', 1]
    ];
    potFractions.forEach(([label, frac]) => {
      const betSize = Math.max(1, Math.round(totalPot * frac));
      addPreset(label, actor.currentBet + callAmt + betSize);
    });
    [2, 3, 4].forEach(mult => {
      const betSize = Math.max(1, Math.round(totalPot * mult));
      addPreset(`x${mult}`, actor.currentBet + callAmt + betSize, 'is-multi');
    });
  }
  addPreset('ALL IN', actor.currentBet + actor.chips);
  updateActivePreset();
  updateRaiseMinLabel();
  updateRaiseError();
}

function updateRaiseMinLabel() {
  const el = document.getElementById('raise-min-label');
  if (!el || !gameState) return;
  const minRaiseTo = gameState.currentMaxBet + gameState.lastRaiseSize;
  raiseMinTo = minRaiseTo;
  setTextWithBump(el, `Min Raise: ${formatAmount(minRaiseTo)}`);
}

function updateInitialChipsBB() {
  const bb = parseInt(document.getElementById('bb-input')?.value || '0', 10) || 0;
  const chips = parseInt(document.getElementById('initial-chips-input')?.value || '0', 10) || 0;
  const el = document.getElementById('initial-chips-bb');
  if (!el) return;
  const bbValue = bb > 0 ? Math.floor(chips / bb) : 0;
  el.textContent = `ÂàùÊúü„ÉÅ„ÉÉ„ÉóÔºö${chips.toLocaleString()}Ôºà= ${bbValue} BBÔºâ`;
}

function updateRaiseError() {
  const el = document.getElementById('raise-error');
  if (!el || !gameState) return;
  const actor = gameState.players[gameState.currentPlayerIndex];
  const allInTo = actor.currentBet + actor.chips;
  if (raiseValue < raiseMinTo && raiseValue < allInTo) {
    el.style.display = 'block';
    el.textContent = `„É¨„Ç§„Ç∫„ÅØ ${formatAmount(raiseMinTo)} ‰ª•‰∏ä`;
  } else {
    el.style.display = 'none';
    el.textContent = '';
  }
}

function updateActivePreset() {
  const presetBtns = document.querySelectorAll('.raise-preset-btn');
  presetBtns.forEach(btn => {
    const amt = parseInt(btn.dataset.amount || '0', 10);
    btn.classList.toggle('active', amt === raiseValue);
  });
}

function toggleRaiseArea() {
  const area = document.getElementById('raise-area');
  if (area.classList.contains('visible')) {
    // Second tap ‚Üí execute raise
    const actor = gameState?.players?.[gameState.currentPlayerIndex];
    const allInTo = actor ? actor.currentBet + actor.chips : raiseValue;
    if (raiseValue < raiseMinTo && raiseValue < allInTo) {
      updateRaiseError();
      return;
    }
    doAction('raise', raiseValue);
  } else {
    area.classList.add('visible');
    updateRaisePresets();
  }
}

let foldConfirmShown = false; // „Éï„Ç©„Éº„É´„ÉâÁ¢∫Ë™çÊ∏à„Åø„Éï„É©„Ç∞

function showFoldConfirm() {
  const overlay = document.getElementById('fold-confirm-overlay');
  overlay.classList.add('visible');
}

function hideFoldConfirm() {
  const overlay = document.getElementById('fold-confirm-overlay');
  overlay.classList.remove('visible');
}

function handleFoldAttempt() {
  if (!gameState) return;
  const actor = gameState.players[gameState.currentPlayerIndex];
  const callAmt = gameState.currentMaxBet - actor.currentBet;

  // „ÉÅ„Çß„ÉÉ„ÇØ„Åß„Åç„ÇãÁä∂Ê≥Å„Åß„ÄÅ„Åæ„Å†Á¢∫Ë™ç„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà
  if (callAmt === 0 && !foldConfirmShown) {
    foldConfirmShown = true;
    showFoldConfirm();
    return;
  }

  // Á¢∫Ë™çÊ∏à„Åø„Åæ„Åü„ÅØ„Ç≥„Éº„É´„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØÁõ¥Êé•„Éï„Ç©„Éº„É´„Éâ
  doAction('fold');
}

function handlePhaseTransition() {
  if (!gameState) { lastPhase = null; return; }
  if (gameState.phase === 'showdown' && lastPhase !== 'showdown') {
    stopActionTimer();
    showShowdown();
  }
  if (gameState.phase !== 'showdown' && lastPhase === 'showdown') {
    document.getElementById('showdown-overlay').classList.remove('visible');
  }
  lastPhase = gameState.phase;
}

function doAction(type, amount = 0) {
  if (actionLock) return;
  if (onlineState.joinMode === 'watch') return;
  if (onlineState.role === 'player') {
    if (gameState) {
      const actor = gameState.players[gameState.currentPlayerIndex];
      localPendingActionKey = `${actor.id}:${gameState.currentMaxBet}:${gameState.phase}`;
      renderActionPanel();
    }
    sendActionRequest(type, amount);
    return;
  }
  if (!gameState) return;
  const prevState = gameState;
  const actorId = gameState.players[gameState.currentPlayerIndex]?.id;
  const actionKey = `${actorId}:${gameState.currentPlayerIndex}:${gameState.currentMaxBet}:${gameState.phase}`;
  if (lastActionId === actionKey) return;
  actionLock = true;
  const result = processAction(gameState, type, amount);
  if (result.error) { console.warn(result.error); return; }
  gameState = result;
  if (hasNewAllIn(prevState, gameState)) playAllInHit();
  lastActionId = actionKey;

  // Hide raise area after action
  document.getElementById('raise-area').classList.remove('visible');

  render();

  if (gameState.isHandActive) {
    // Restart timer for next player
    startActionTimer();
  }
  if (onlineState.role === 'host') {
    broadcastState();
  }
  actionLock = false;
}

function render() {
  renderPlayers();
  renderPot();
  renderCommunityCards();
  renderPhase();
  renderActionPanel();
  updateJoinStatusBanner();
  handlePhaseTransition();
}

// ‚îÄ‚îÄ‚îÄ SHOWDOWN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showShowdown() {
  const total = (gameState.pots||[]).reduce((s,p) => s + p.amount, 0);
  document.getElementById('showdown-pot-amount').textContent = formatAmount(total);
  document.getElementById('next-hand-overlay').classList.remove('visible');
  document.getElementById('fold-confirm-overlay').classList.remove('visible');

  if (onlineState.role === 'player') {
    const card = document.querySelector('#showdown-overlay .showdown-card');
    if (card) {
      card.innerHTML = `
        <div class="showdown-title">„Éõ„Çπ„Éà„ÅåÁµêÊûú„ÇíÁ¢∫ÂÆö„Åó„Å¶„ÅÑ„Åæ„Åô</div>
        <div class="showdown-pot">${formatAmount(total)}</div>
        <div class="showdown-pot-label">TOTAL POT</div>
        <div class="waiting-subtext" style="margin-top:12px;">„Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ</div>
      `;
    }
    document.getElementById('showdown-overlay').classList.add('visible');
    return;
  }

  // Eligible players (not folded AND not out)
  const eligible = gameState.players.filter(p => p.status !== 'folded' && p.status !== 'out');
  const selectEl = document.getElementById('winner-select');
  selectEl.innerHTML = '';
  selectedWinners = [];
  isSplitMode = false;
  const splitToggle = document.getElementById('split-toggle');
  const splitWrap = splitToggle ? splitToggle.closest('.split-toggle') : null;
  const confirmBtn = document.getElementById('confirm-winner-btn');
  if (splitToggle) splitToggle.classList.remove('on');
  if (splitWrap) splitWrap.style.display = eligible.length >= 2 ? 'flex' : 'none';
  if (confirmBtn) confirmBtn.disabled = true;

  // 1‰∫∫„Åó„Åã„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØËá™ÂãïÈÅ∏Êäû
  if (eligible.length === 1) {
    selectedWinners = [eligible[0].id];
    if (confirmBtn) confirmBtn.disabled = false;
    confirmWinner();
    return;
  } else {
    eligible.forEach(player => {
      const btn = document.createElement('button');
      btn.className = 'winner-btn';
      btn.dataset.playerId = player.id;
      btn.innerHTML = `
      <div class="w-avatar">${player.name.charAt(0).toUpperCase()}</div>
      <span class="w-name">${player.name}</span>
      <span class="w-chips">${formatAmount(player.chips)}</span>
      `;
      // „Çø„ÉÉ„ÉÅ„Å®„ÇØ„É™„ÉÉ„ÇØ‰∏°ÂØæÂøú
      const handleSelect = (e) => {
        e.preventDefault();
        e.stopPropagation();
        selectWinner(btn, player.id);
      };
      btn.addEventListener('click', handleSelect);
      btn.addEventListener('touchend', handleSelect);
      selectEl.appendChild(btn);
    });
  }

  document.getElementById('showdown-overlay').classList.add('visible');
}

function selectWinner(btn, playerId) {
  if (onlineState.role === 'player') return;
  if (isSplitMode) {
    btn.classList.toggle('selected');
    if (selectedWinners.includes(playerId)) {
      selectedWinners = selectedWinners.filter(id => id !== playerId);
    } else {
      selectedWinners.push(playerId);
    }
  } else {
    // Single select
    document.querySelectorAll('.winner-btn').forEach(b => b.classList.remove('selected'));
    btn.classList.add('selected');
    selectedWinners = [playerId];
  }
  document.getElementById('confirm-winner-btn').disabled = selectedWinners.length === 0;
}

function toggleSplit() {
  if (onlineState.role === 'player') return;
  isSplitMode = !isSplitMode;
  document.getElementById('split-toggle').classList.toggle('on', isSplitMode);
  if (!isSplitMode) {
    // Reset to single select
    if (selectedWinners.length > 1) selectedWinners = [selectedWinners[0]];
    document.querySelectorAll('.winner-btn').forEach(b => {
      const keep = selectedWinners.includes(b.dataset.playerId);
      b.classList.toggle('selected', keep);
    });
    document.getElementById('confirm-winner-btn').disabled = selectedWinners.length === 0;
  }
}

function confirmWinner() {
  if (onlineState.role === 'player') return;
  if (confirmLock || selectedWinners.length === 0) return;
  confirmLock = true;
  setTimeout(() => { confirmLock = false; }, 200);
  const totalPot = getPotTotal(gameState);
  const per = selectedWinners.length ? Math.floor(totalPot / selectedWinners.length) : 0;
  const rem = totalPot - per * selectedWinners.length;

  const winnerIds = selectedWinners.slice();
  const winners = selectedWinners.map(id => {
    const p = gameState.players.find(p => p.id === id);
    return { name: p?.name || '‚Äî', icon: p?.icon || '' };
  });
  gameState = distributePot(gameState, selectedWinners);
  recordHandResult(winners, totalPot);
  document.getElementById('showdown-overlay').classList.remove('visible');
  render();
  setWinnerHighlight(winnerIds);
  animatePotToWinners(winnerIds);
  playWinChime();

  // ÂãùËÄÖ„ÅÆÂÆüÈöõ„ÅÆÊêçÁõä„ÇíË®àÁÆó
  const winnerGains = winnerIds.map(id => {
    const p = gameState.players.find(pl => pl.id === id);
    const before = chipsBeforeHand[id] || p.chips;
    return p.chips - before;
  });
  let gainText = '';
  if (selectedWinners.length === 1) {
    const gain = winnerGains[0];
    gainText = `${gain >= 0 ? '+' : ''}${gain.toLocaleString()} „ÉÅ„ÉÉ„Éó`;
  } else {
    const totalGain = winnerGains.reduce((a, b) => a + b, 0);
    gainText = `ÂêàË®à ${totalGain >= 0 ? '+' : ''}${totalGain.toLocaleString()} „ÉÅ„ÉÉ„Éó`;
  }
  setTimeout(() => showNextHand(winners, gainText), 220);

  // Broadcast resolution so non-host clients can exit showdown
  if (onlineState.role === 'host' && roomChannel) {
    roomChannel.send({
      type: 'broadcast',
      event: 'showdown-resolved',
      payload: { winnerIds: selectedWinners }
    });
    broadcastState();
  }
}

// ‚îÄ‚îÄ‚îÄ NEXT HAND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showNextHand(winners, gainText = '') {
  const winnersEl = document.getElementById('next-hand-winners');
  winnersEl.innerHTML = winners.map(w => `
    <div class="next-hand-winner-item">
      <div class="next-hand-winner-avatar">${w.icon || w.name.charAt(0).toUpperCase()}</div>
      <div class="next-hand-winner-name">${w.name}</div>
    </div>
  `).join('');
  document.getElementById('next-hand-gain').textContent = gainText;

  // Render inline chip status
  const chipStatusEl = document.getElementById('next-hand-chip-status');
  if (gameState && gameState.players) {
    chipStatusEl.innerHTML = gameState.players.map(p => {
      const before = chipsBeforeHand[p.id] || p.chips;
      const change = p.chips - before;
      const changeClass = change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral';
      const changeText = change > 0 ? `+${change.toLocaleString()}` : change < 0 ? change.toLocaleString() : '¬±0';
      return `
        <div class="next-hand-chip-row">
          <div class="next-hand-chip-avatar">${p.icon || p.name.charAt(0).toUpperCase()}</div>
          <div class="next-hand-chip-name">${p.name}</div>
          <div class="next-hand-chip-amount">${p.chips.toLocaleString()}</div>
          <div class="next-hand-chip-change ${changeClass}">${changeText}</div>
        </div>
      `;
    }).join('');
  }

  document.getElementById('showdown-overlay').classList.remove('visible');
  document.getElementById('fold-confirm-overlay').classList.remove('visible');
  document.getElementById('next-hand-overlay').classList.add('visible');
  const btn = document.getElementById('next-hand-btn');
  if (btn) {
    if (onlineState.role !== 'player') {
      btn.disabled = false;
      btn.textContent = 'Ê¨°„ÅÆ„Éè„É≥„Éâ';
    } else {
      btn.disabled = true;
      btn.textContent = '„Éõ„Çπ„Éà„ÅÆÊìç‰Ωú„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô';
    }
  }
  // flash
  const flash = document.getElementById('win-flash');
  flash.classList.add('visible');
  setTimeout(() => flash.classList.remove('visible'), 600);
}

function showChipStatus() {
  const tableEl = document.getElementById('chip-status-table');
  if (!gameState || !gameState.players) return;

  tableEl.innerHTML = gameState.players.map(p => {
    const before = chipsBeforeHand[p.id] || p.chips;
    const change = p.chips - before;
    const changeClass = change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral';
    const changeText = change > 0 ? `+${change.toLocaleString()}` : change < 0 ? change.toLocaleString() : '¬±0';
    return `
      <div class="chip-status-row">
        <div class="chip-status-avatar">${p.icon || p.name.charAt(0).toUpperCase()}</div>
        <div class="chip-status-name">${p.name}</div>
        <div class="chip-status-chips">${p.chips.toLocaleString()}</div>
        <div class="chip-status-change ${changeClass}">${changeText}</div>
      </div>
    `;
  }).join('');

  document.getElementById('chip-status-overlay').classList.add('visible');
}

function hideChipStatus() {
  document.getElementById('chip-status-overlay').classList.remove('visible');
  document.getElementById('next-hand-overlay').classList.remove('visible');
}

function showHistory() {
  updateHistoryView();
  document.getElementById('history-overlay').classList.add('visible');
  document.getElementById('header-menu').style.display = 'none';
}

function hideHistory() {
  document.getElementById('history-overlay').classList.remove('visible');
}

function getHistoryFilterValues() {
  const handInput = document.getElementById('history-filter-hand');
  const winnerInput = document.getElementById('history-filter-winner');
  const minPotInput = document.getElementById('history-filter-minpot');
  return {
    hand: handInput ? parseInt(handInput.value, 10) : null,
    winner: winnerInput ? winnerInput.value.trim().toLowerCase() : '',
    minPot: minPotInput ? parseInt(minPotInput.value, 10) : null
  };
}

function filterHistoryList(list) {
  const filter = getHistoryFilterValues();
  return list.filter(h => {
    if (Number.isFinite(filter.hand) && filter.hand > 0 && h.hand !== filter.hand) return false;
    if (Number.isFinite(filter.minPot) && filter.minPot > 0 && h.pot < filter.minPot) return false;
    if (filter.winner) {
      const winners = (h.winners || []).map(w => (w.name || '').toLowerCase());
      if (!winners.some(n => n.includes(filter.winner))) return false;
    }
    return true;
  });
}

function renderHistoryList(list) {
  const listEl = document.getElementById('history-list');
  if (!listEl) return;
  if (list.length === 0) {
    listEl.innerHTML = '<div class="history-empty">‰∏ÄËá¥„Åô„ÇãÂ±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
    return;
  }
  listEl.innerHTML = list.map(h => {
    const winnerText = h.winners.map(w =>
      `<span class="history-winner">${w.icon || ''} ${w.name} +${Math.floor(h.pot / h.winners.length).toLocaleString()}</span>`
    ).join(' ');
    const loserText = h.losers.map(l =>
      `<span class="history-loser">${l.icon || ''} ${l.name} -${l.loss.toLocaleString()}</span>`
    ).join(' ');
    return `
      <div class="history-item">
        <div class="history-header">No.${h.hand} (Pot: ${h.pot.toLocaleString()})</div>
        <div class="history-result">
          ${winnerText}
          ${loserText}
        </div>
      </div>
    `;
  }).join('');
}

function updateHistoryView() {
  const list = handHistory.length ? filterHistoryList(handHistory) : [];
  if (handHistory.length === 0) {
    const listEl = document.getElementById('history-list');
    if (listEl) listEl.innerHTML = '<div class="history-empty">„Åæ„Å†Â±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
    return;
  }
  renderHistoryList(list);
}

function showDisconnectDialog() {
  document.getElementById('disconnect-overlay').classList.add('visible');
}

function hideDisconnectDialog() {
  document.getElementById('disconnect-overlay').classList.remove('visible');
}

function saveChipsBeforeHand() {
  if (!gameState || !gameState.players) return;
  chipsBeforeHand = {};
  gameState.players.forEach(p => {
    chipsBeforeHand[p.id] = p.chips;
  });
}

function recordHandResult(winners, totalPot) {
  if (!gameState || !gameState.players) return;
  const losers = gameState.players.filter(p =>
    !winners.some(w => w.name === p.name) && chipsBeforeHand[p.id] !== p.chips
  );
  handHistory.push({
    hand: handHistory.length + 1,
    winners: winners.map(w => ({ name: w.name, icon: w.icon })),
    losers: losers.map(l => ({ name: l.name, icon: l.icon, loss: chipsBeforeHand[l.id] - l.chips })),
    pot: totalPot
  });
}

function nextHand() {
  if (nextHandLock) return;
  if (onlineState.role === 'player') return;
  nextHandLock = true;
  setTimeout(() => { nextHandLock = false; }, 200);
  document.getElementById('next-hand-overlay').classList.remove('visible');
  advanceToNextHandAndBroadcast();
}

function showGameOver() {
  const winner = gameState.players.find(p => p.chips > 0);
  const overlay = document.getElementById('next-hand-overlay');
  const winnersEl = document.getElementById('next-hand-winners');
  if (winner) {
    winnersEl.innerHTML = `
      <div class="next-hand-winner-item">
        <div class="next-hand-winner-avatar">${winner.icon || winner.name.charAt(0).toUpperCase()}</div>
        <div class="next-hand-winner-name">${winner.name}</div>
      </div>
    `;
    document.querySelector('.next-hand-sub').textContent = '„ÅåÂÑ™ÂãùÔºÅ';
  } else {
    winnersEl.innerHTML = '<div class="next-hand-winner-name">„Ç≤„Éº„É†ÁµÇ‰∫Ü</div>';
    document.querySelector('.next-hand-sub').textContent = '';
  }
  document.getElementById('next-hand-gain').textContent = '';
  overlay.classList.add('visible');
  // „Éú„Çø„É≥„Çí„ÄåÊñ∞„Åó„ÅÑ„Ç≤„Éº„É†„Äç„Å´Â§âÊõ¥
  const btn = overlay.querySelector('.next-hand-btn');
  if (btn) {
    if (onlineState.role !== 'player') {
      btn.disabled = false;
      btn.textContent = 'Êñ∞„Åó„ÅÑ„Ç≤„Éº„É†';
      btn.onclick = () => {
        overlay.classList.remove('visible');
        setUiState('room');
        if (roomChannel) {
          roomChannel.send({ type: 'broadcast', event: 'ui-phase', payload: { phase: 'room' } });
        }
      };
    } else {
      btn.disabled = true;
      btn.textContent = '„Éõ„Çπ„Éà„ÅÆÊìç‰Ωú„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô';
      btn.onclick = null;
    }
  }
}

function removePendingExits(state) {
  if (!state || !state.players) return state;
  const pending = new Set(
    getPresenceList()
      .filter(p => p.role === 'player' && p.pendingExit && p.name)
      .map(p => p.name)
  );
  if (pending.size === 0) return state;
  const remaining = state.players.filter(p => !pending.has(p.name));
  if (remaining.length === state.players.length) return state;
  state.players = remaining;
  if (state.dealerIndex >= remaining.length) {
    state.dealerIndex = Math.max(0, remaining.length - 1);
  }
  if (state.currentPlayerIndex >= remaining.length) {
    state.currentPlayerIndex = Math.max(0, remaining.length - 1);
  }
  return state;
}

function advanceToNextHandAndBroadcast() {
  if (onlineState.role === 'host') {
    gameState = removePendingExits(gameState);
    gameState = addLateJoiners(gameState);
    gameState = applyRebuys(gameState);
  }
  gameState = advanceDealer(gameState);
  saveChipsBeforeHand();  // SB/BBÊâï„ÅÜÂâç„Å´Ë®òÈå≤
  gameState = startHand(gameState);

  if (gameState.phase === 'finished') {
    showGameOver();
    return;
  }

  render();
  startActionTimer();
  if (onlineState.role === 'host') {
    broadcastState();
  }
}

function getLateJoinRequests() {
  if (!gameState) return [];
  const list = getPresenceList();
  const existingNames = new Set(gameState.players.map(p => p.name));
  return list.filter(p =>
    p.role === 'player' &&
    !isSpectator(p) &&
    p.joinConfirmed === true &&
    p.name &&
    !existingNames.has(p.name)
  );
}

function getNextPlayerId(state) {
  if (!state || !state.players) return 0;
  let maxId = -1;
  state.players.forEach(p => {
    const match = /player_(\d+)/.exec(p.id || '');
    if (match) {
      const num = parseInt(match[1], 10);
      if (Number.isFinite(num)) maxId = Math.max(maxId, num);
    }
  });
  return maxId + 1;
}

function addLateJoiners(state) {
  if (!state) return state;
  const lateJoin = state.lateJoinSettings || lateJoinSettings;
  if (!lateJoin?.enabled) return state;
  const requests = getLateJoinRequests();
  if (requests.length === 0) return state;
  const nextIdStart = getNextPlayerId(state);
  let nextId = nextIdStart;
  const cap = Number.isFinite(lateJoin.maxChips) && lateJoin.maxChips >= 1 ? lateJoin.maxChips : 1000;
  const newPlayers = requests.map(req => {
    const startingChips = cap;
    const name = req.name || `Player ${nextId + 1}`;
    return {
      id: `player_${nextId++}`,
      name,
      icon: '',
      chips: startingChips,
      status: "waiting",
      currentBet: 0,
      totalBet: 0,
      actedThisRound: false
    };
  });
  return { ...state, players: [...state.players, ...newPlayers] };
}

function getRebuyRequests(state) {
  if (!state || !state.players) return [];
  const list = getPresenceList();
  const playersByName = new Map(state.players.map(p => [p.name, p]));
  return list.filter(p => {
    if (!p || !p.name || !p.rebuyRequested) return false;
    const entry = playersByName.get(p.name);
    return entry && entry.chips <= 0;
  });
}

function applyRebuys(state) {
  if (!state || !state.players) return state;
  const lateJoin = state.lateJoinSettings || lateJoinSettings;
  const rebuyChips = Number.isFinite(lateJoin?.maxChips) && lateJoin.maxChips >= 1 ? lateJoin.maxChips : 1000;
  const requests = getRebuyRequests(state);
  if (requests.length === 0) return state;
  const updates = new Set(requests.map(r => r.name));
  const players = state.players.map(p => {
    if (!updates.has(p.name)) return p;
    return {
      ...p,
      chips: rebuyChips,
      status: "waiting",
      currentBet: 0,
      totalBet: 0,
      actedThisRound: false
    };
  });
  return { ...state, players };
}

// ‚îÄ‚îÄ‚îÄ SETUP SCREEN LOGIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function addPlayer() {
  const inputs = document.getElementById('player-inputs');
  const playerNum = inputs.querySelectorAll('.player-row').length + 1;
  const row = document.createElement('div');
  row.className = 'player-row';
  const zenkakuNum = String(playerNum).replace(/[0-9]/g, s => String.fromCharCode(s.charCodeAt(0) + 0xFEE0));
  row.innerHTML = `<input type="text" class="player-name-input" placeholder="„Éó„É¨„Ç§„É§„ÉºÂêç" value="„Éó„É¨„Ç§„É§„Éº${zenkakuNum}"><div class="icon-picker"></div><button class="remove-btn" onclick="removePlayer(this)">√ó</button>`;
  inputs.appendChild(row);
  refreshIconPickers();
}

function removePlayer(btn) {
  const inputs = document.querySelectorAll('.player-row');
  if (inputs.length <= 2) return; // ÊúÄ‰Ωé2‰∫∫
  btn.closest('.player-row').remove();
  refreshIconPickers();
}

function startGame() {
  if (onlineState.role === 'player') {
    setRoomStatus('„Éõ„Çπ„Éà„ÅåÈñãÂßã„Åó„Åæ„Åô');
    return;
  }
  const settings = collectSettingsFromForm();
  let players = [];
  if (onlineState.role === 'host') {
    players = getOnlinePlayers();
    if (players.length < 2) {
      const hostStatus = document.getElementById('waiting-host-status');
      if (hostStatus) hostStatus.textContent = 'ÂèÇÂä†ËÄÖ„ÅåË∂≥„Çä„Åæ„Åõ„Çì';
      return;
    }
  } else {
    players = getLocalPlayers();
    if (players.length < 2) return;
    localStorage.setItem('pokerPlayerNames', JSON.stringify(getLocalPlayerFormData()));
  }

  startGameWithPlayers(players, settings);

  if (onlineState.role === 'host' && roomChannel) {
    broadcastState();
    roomChannel.send({ type: 'broadcast', event: 'start-game', payload: { settings, state: gameState } });
    roomChannel.send({ type: 'broadcast', event: 'ui-phase', payload: { phase: 'playing' } });
  }
  updatePlayerBadge();
}

// Load saved player names on page load
function loadSavedPlayerNames() {
  const saved = localStorage.getItem('pokerPlayerNames');
  if (!saved) return;

  try {
    const savedData = JSON.parse(saved);
    if (!Array.isArray(savedData) || savedData.length === 0) return;

    const container = document.getElementById('player-inputs');
    container.innerHTML = '';

    savedData.forEach((entry) => {
      const name = typeof entry === 'string' ? entry : (entry?.name || '');
      const icon = typeof entry === 'string' ? '' : (entry?.icon || '');
      const row = document.createElement('div');
      row.className = 'player-row';
      row.dataset.icon = icon;
      row.innerHTML = `<input type="text" class="player-name-input" placeholder="„Éó„É¨„Ç§„É§„ÉºÂêç" value="${name}"><div class="icon-picker"></div><button class="remove-btn" onclick="removePlayer(this)">√ó</button>`;
      container.appendChild(row);
    });
    refreshIconPickers();
  } catch (e) {
    console.log('Failed to load saved player names:', e);
  }
}

function syncTournamentOptions() {
  const toggle = document.getElementById('tournament-mode-toggle');
  const options = document.getElementById('tournament-options');
  if (!toggle || !options) return;
  options.style.display = toggle.checked ? 'block' : 'none';
}

// „É©„É≥„ÉÄ„É†Ë°®Á§∫ÂêçÁîüÊàêÔºà„Éù„Éº„Ç´„ÉºÈ¢®„ÅÆ„Éã„ÉÉ„ÇØ„Éç„Éº„É†Ôºâ
function generateRandomName() {
  const animals = ['Fox', 'Wolf', 'Bear', 'Lion', 'Hawk', 'Owl', 'Cat', 'Dog'];
  const animal = animals[Math.floor(Math.random() * animals.length)];
  const num = Math.floor(10 + Math.random() * 90);
  return `${animal}${num}`;
}

const ICON_OPTIONS = ['ü¶ñ', 'üê±', 'üê∂', 'üêº', 'üê∏', 'üêµ', 'ü¶ä', 'üêØ'];

function buildIconPicker(row, selectedIcon, index) {
  const picker = row.querySelector('.icon-picker');
  if (!picker) return;
  const fallback = ICON_OPTIONS[index % ICON_OPTIONS.length];
  const current = selectedIcon || row.dataset.icon || fallback;
  row.dataset.icon = current;
  picker.innerHTML = '';
  ICON_OPTIONS.forEach(icon => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'icon-btn' + (icon === current ? ' selected' : '');
    btn.textContent = icon;
    btn.dataset.icon = icon;
    btn.addEventListener('click', () => {
      row.dataset.icon = icon;
      picker.querySelectorAll('.icon-btn').forEach(b => {
        b.classList.toggle('selected', b.dataset.icon === icon);
      });
    }, { passive: true });
    picker.appendChild(btn);
  });
}

function refreshIconPickers() {
  const rows = document.querySelectorAll('.player-row');
  rows.forEach((row, i) => buildIconPicker(row, row.dataset.icon, i));
}

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', () => {
  if ('scrollRestoration' in history) {
    history.scrollRestoration = 'manual';
  }
  window.scrollTo(0, 0);
  loadSavedPlayerNames();
  refreshIconPickers();
  setUiState('room');
  const versionEl = document.getElementById('app-version');
  if (versionEl) versionEl.textContent = APP_VERSION;
  setupNumericInput(document.getElementById('sb-input'));
  setupNumericInput(document.getElementById('bb-input'));
  setupNumericInput(document.getElementById('initial-chips-input'));
  setupNumericInput(document.getElementById('late-join-max-chips'));
  const lateJoinToggle = document.getElementById('late-join-toggle');
  const lateJoinMaxInput = document.getElementById('late-join-max-chips');
  if (lateJoinToggle && lateJoinMaxInput) {
    const syncLateJoinOptions = () => {
      lateJoinMaxInput.disabled = !lateJoinToggle.checked;
    };
    syncLateJoinOptions();
    lateJoinToggle.addEventListener('change', syncLateJoinOptions);
  }

  const toggle = document.getElementById('tournament-mode-toggle');
  if (toggle) {
    bindOnce(toggle, 'change', syncTournamentOptions);
  }
  syncTournamentOptions();
  const perPlayerToggle = document.getElementById('per-player-stack-toggle');
  if (perPlayerToggle) {
    bindOnce(perPlayerToggle, 'change', renderPerPlayerStackList);
    bindOnce(perPlayerToggle, 'change', updateInitialChipsBB);
  }
  const bbInput = document.getElementById('bb-input');
  if (bbInput) {
    bindOnce(bbInput, 'input', updateInitialChipsBB);
    bindOnce(bbInput, 'input', updatePerPlayerBBDisplays);
    bindOnce(bbInput, 'change', updateInitialChipsBB);
    bindOnce(bbInput, 'change', updatePerPlayerBBDisplays);
  }
  const chipsInput = document.getElementById('initial-chips-input');
  if (chipsInput) {
    bindOnce(chipsInput, 'input', updateInitialChipsBB);
    bindOnce(chipsInput, 'change', updateInitialChipsBB);
    bindOnce(chipsInput, 'blur', updateInitialChipsBB);
  }
  updateInitialChipsBB();

  const hostBtn = document.getElementById('room-host-btn');
  const joinBtn = document.getElementById('room-join-btn');
  const localBtn = document.getElementById('room-local-btn');
  const leaveBtn = document.getElementById('room-leave-btn');
  const waitingStartBtn = document.getElementById('waiting-start-btn');
  const copyBtn = document.getElementById('room-copy-btn');
  const settingsLeaveBtn = document.getElementById('settings-leave-btn');
  const codeInput = document.getElementById('room-code-input');
  const nameInput = document.getElementById('display-name-input');

  // „Éá„Éï„Ç©„É´„Éà„Åß„É©„É≥„ÉÄ„É†Âêç„ÇíË®≠ÂÆö
  reconnectInfo = loadReconnectInfo();
  if (nameInput && !nameInput.value) {
    if (reconnectInfo && reconnectInfo.displayName) {
      nameInput.value = reconnectInfo.displayName;
    } else {
      nameInput.value = generateRandomName();
    }
  }
  const storedSound = localStorage.getItem(SOUND_STORAGE_KEY);
  if (storedSound === '0' || storedSound === '1') {
    setSoundEnabled(storedSound === '1', false);
  } else {
    updateSoundMenuLabel();
  }
  const startBtn = document.getElementById('start-btn');
  const menuBtn = document.getElementById('menu-btn');
  const menu = document.getElementById('header-menu');
  const menuResetBtn = document.getElementById('menu-reset-btn');
  const menuJoinBtn = document.getElementById('menu-join-btn');
  const menuSoundBtn = document.getElementById('menu-sound-toggle');
  const soundToggle = document.getElementById('timer-sound-toggle');
  const awayToggle = document.getElementById('away-toggle');
  const exitNextHandBtn = document.getElementById('exit-next-hand-btn');
  const historyFilterHand = document.getElementById('history-filter-hand');
  const historyFilterWinner = document.getElementById('history-filter-winner');
  const historyFilterMinPot = document.getElementById('history-filter-minpot');
  const historyFilterClear = document.getElementById('history-filter-clear');
  const joinSeatBtn = document.getElementById('join-seat-btn');
  const joinCancelBtn = document.getElementById('join-cancel-btn');
  const rebuyRequestBtn = document.getElementById('rebuy-request-btn');
  const seatSelectCancelBtn = document.getElementById('seat-select-cancel-btn');
  const joinCancelNoBtn = document.getElementById('join-cancel-no');
  const joinCancelYesBtn = document.getElementById('join-cancel-yes');
  const reconnectWatchBtn = document.getElementById('reconnect-watch-btn');
  const reconnectPlayBtn = document.getElementById('reconnect-play-btn');
  const reconnectCancelBtn = document.getElementById('reconnect-cancel-btn');
  if (awayToggle) {
    bindOnce(awayToggle, 'change', () => {
      if (onlineState.role !== 'player') return;
      onlineState.away = awayToggle.checked;
      updatePresence({ away: onlineState.away });
      updateAwayControls();
      showToast(onlineState.away ? 'Èõ¢Â∏≠‰∏≠ÔºöËá™Âãï„Éï„Ç©„Éº„É´„Éâ' : 'Èõ¢Â∏≠Ëß£Èô§', 'info');
    });
  }
  if (exitNextHandBtn) {
    bindOnce(exitNextHandBtn, 'click', () => {
      if (onlineState.role !== 'player') return;
      onlineState.pendingExit = !onlineState.pendingExit;
      updatePresence({ pendingExit: onlineState.pendingExit });
      updateAwayControls();
      showToast(onlineState.pendingExit ? 'Ê¨°„Éè„É≥„Éâ„ÅßÈÄÄÂá∫„Çí‰∫àÁ¥Ñ„Åó„Åæ„Åó„Åü' : 'ÈÄÄÂá∫‰∫àÁ¥Ñ„Çí„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü', 'info');
    });
  }
  if (hostBtn) {
    hostBtn.addEventListener('click', async () => {
      onlineState.displayName = nameInput ? nameInput.value.trim() : '';
      onlineState.ready = false;
      onlineState.seat = '';
      updatePlayerBadge();
      if (!onlineState.displayName) {
        setRoomStatus('ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
        return;
      }
      if (codeInput) codeInput.value = '';
      const ok = await createRoomWithUniqueCode();
      if (ok) {
        onlineState.role = 'host';
        setUiState('waiting');
        updateParticipantList();
      }
    });
  }
  if (joinBtn) {
    joinBtn.addEventListener('click', async () => {
      onlineState.displayName = nameInput ? nameInput.value.trim() : '';
      onlineState.ready = false;
      onlineState.seat = '';
      updatePlayerBadge();
      if (!onlineState.displayName) {
        setRoomStatus('ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
        return;
      }
      const code = codeInput ? codeInput.value : '';
      const ok = await joinRoom('player', code);
      if (ok) {
        onlineState.role = 'player';
        setUiState('waiting');
        updateParticipantList();
      }
    });
  }
  if (localBtn) {
    localBtn.addEventListener('click', () => {
      onlineState.displayName = nameInput ? nameInput.value.trim() : '';
      onlineState.role = 'local';
      updatePlayerBadge();
      setUiState('settings');
      updateSettingsPanels();
    });
  }
  if (leaveBtn) {
    leaveBtn.addEventListener('click', () => {
      leaveRoom({ clearReconnect: true });
    });
  }
  if (settingsLeaveBtn) {
    settingsLeaveBtn.addEventListener('click', () => {
      leaveRoom({ clearReconnect: true });
    });
  }
  if (waitingStartBtn) {
    waitingStartBtn.addEventListener('click', () => {
      if (onlineState.role !== 'host') return;
      setUiState('settings');
      updateSettingsPanels();
      if (roomChannel) {
        roomChannel.send({ type: 'broadcast', event: 'ui-phase', payload: { phase: 'settings' } });
      }
    });
  }
  const waitingBackBtn = document.getElementById('waiting-back-btn');
  if (waitingBackBtn) {
    waitingBackBtn.addEventListener('click', () => {
      leaveRoom({ clearReconnect: true });
    });
  }
  const settingsBackBtn = document.getElementById('settings-back-btn');
  if (settingsBackBtn) {
    settingsBackBtn.addEventListener('click', () => {
      if (onlineState.role === 'local') {
        setUiState('room');
      } else {
        leaveRoom({ clearReconnect: true });
      }
    });
  }
  if (startBtn) {
    startBtn.addEventListener('click', () => {
      startGame();
    });
  }
  if (copyBtn) {
    copyBtn.addEventListener('click', async () => {
      const code = onlineState.roomCode || '';
      if (!code) return;
      try {
        await navigator.clipboard.writeText(code);
        copyBtn.textContent = 'COPIED';
        setTimeout(() => { copyBtn.textContent = 'COPY'; }, 1200);
      } catch (e) {}
    });
  }
  if (codeInput) {
    bindOnce(codeInput, 'blur', () => {
      codeInput.value = normalizeRoomCode(codeInput.value);
    });
    const focusRoomInput = () => setTimeout(() => codeInput.focus(), 0);
    bindOnce(codeInput, 'click', focusRoomInput, { passive: true });
    bindOnce(codeInput, 'touchstart', focusRoomInput, { passive: true });
    const roomRow = codeInput.parentElement;
    if (roomRow) {
      bindOnce(roomRow, 'click', focusRoomInput, { passive: true });
      bindOnce(roomRow, 'touchstart', focusRoomInput, { passive: true });
    }
    bindOnce(codeInput, 'focus', () => debugLog('room-code: focus'), { passive: true });
    bindOnce(codeInput, 'blur', () => debugLog('room-code: blur'), { passive: true });
  }
  if (menuBtn && menu) {
    bindOnce(menuBtn, 'click', () => {
      const open = menu.style.display === 'flex';
      menu.style.display = open ? 'none' : 'flex';
    });
    bindOnce(document, 'click', (e) => {
      if (!menu.contains(e.target) && e.target !== menuBtn) {
        menu.style.display = 'none';
      }
    });
  }
  const displayToggleBtn = document.getElementById('menu-display-toggle');
  if (displayToggleBtn) {
    displayToggleBtn.textContent = `Ë°®Ë®òÂàáÊõø: ${displayMode === 'bb' ? 'BB' : 'CHIP'}`;
    displayToggleBtn.addEventListener('click', () => {
      applyDisplayMode(displayMode === 'bb' ? 'chips' : 'bb');
      if (menu) menu.style.display = 'none';
    });
  }
  const menuHistoryBtn = document.getElementById('menu-history-btn');
  if (menuHistoryBtn) {
    menuHistoryBtn.addEventListener('click', () => {
      showHistory();
    });
  }
  if (menuResetBtn) {
    menuResetBtn.addEventListener('click', () => {
      if (menu) menu.style.display = 'none';
      resetToSetup();
    });
  }
  if (menuJoinBtn) {
    menuJoinBtn.addEventListener('click', () => {
      if (menu) menu.style.display = 'none';
      applyJoinMode('play', getAutoJoinChips());
    });
  }
  if (menuSoundBtn) {
    menuSoundBtn.addEventListener('click', () => {
      setSoundEnabled(!timerSettings.soundEnabled);
      if (onlineState.role === 'host' && roomChannel) {
        roomChannel.send({ type: 'broadcast', event: 'sound-toggle', payload: { enabled: timerSettings.soundEnabled } });
      }
      if (menu) menu.style.display = 'none';
    });
  }
  if (soundToggle) {
    soundToggle.addEventListener('change', () => {
      setSoundEnabled(soundToggle.checked);
      if (onlineState.role === 'host' && roomChannel) {
        roomChannel.send({ type: 'broadcast', event: 'sound-toggle', payload: { enabled: timerSettings.soundEnabled } });
      }
    });
  }
  const historyFilterHandler = () => updateHistoryView();
  if (historyFilterHand) historyFilterHand.addEventListener('input', historyFilterHandler);
  if (historyFilterWinner) historyFilterWinner.addEventListener('input', historyFilterHandler);
  if (historyFilterMinPot) historyFilterMinPot.addEventListener('input', historyFilterHandler);
  if (historyFilterClear) {
    historyFilterClear.addEventListener('click', () => {
      if (historyFilterHand) historyFilterHand.value = '';
      if (historyFilterWinner) historyFilterWinner.value = '';
      if (historyFilterMinPot) historyFilterMinPot.value = '';
      updateHistoryView();
    });
  }
  if (joinSeatBtn) {
    joinSeatBtn.addEventListener('click', () => {
      showSeatSelectModal();
    });
  }
  if (joinCancelBtn) {
    joinCancelBtn.addEventListener('click', () => {
      showJoinCancelConfirm();
    });
  }
  if (rebuyRequestBtn) {
    rebuyRequestBtn.addEventListener('click', () => {
      if (onlineState.role !== 'player') return;
      onlineState.joinMode = 'play';
      onlineState.joinConfirmed = true;
      onlineState.rebuyRequested = true;
      onlineState.requestedChips = getAutoJoinChips();
      updatePresence({
        joinMode: onlineState.joinMode,
        joinConfirmed: onlineState.joinConfirmed,
        requestedChips: onlineState.requestedChips,
        rebuyRequested: true
      });
      showToast('„É™„Éê„Ç§Áî≥Ë´ã„Åó„Åæ„Åó„Åü', 'info');
      updateJoinStatusBanner();
    });
  }
  if (seatSelectCancelBtn) {
    seatSelectCancelBtn.addEventListener('click', () => {
      hideSeatSelectModal();
    });
  }
  if (joinCancelNoBtn) {
    joinCancelNoBtn.addEventListener('click', () => {
      hideJoinCancelConfirm();
    });
  }
  if (joinCancelYesBtn) {
    joinCancelYesBtn.addEventListener('click', () => {
      hideJoinCancelConfirm();
      applyJoinMode('watch', onlineState.requestedChips || 1000);
      updateParticipantList();
      render();
      showToast('Ë¶≥Êà¶„Å´Êàª„Çä„Åæ„Åó„Åü');
    });
  }

  if (reconnectWatchBtn) {
    bindOnce(reconnectWatchBtn, 'click', async () => {
      const chips = getRequestedChips();
      if (reconnectContext === 'startup') {
        const info = reconnectInfo || loadReconnectInfo();
        if (!info || !info.roomCode) return;
        onlineState.displayName = nameInput ? nameInput.value.trim() : '';
        onlineState.joinMode = 'watch';
        onlineState.requestedChips = chips;
        joinChoiceConfirmed = true;
        onlineState.joinConfirmed = true;
        autoEnterOnStateSync = true;
        hideReconnectModal();
        await joinRoom(info.role || 'player', info.roomCode);
        return;
      }
      applyJoinMode('watch', chips);
      hideReconnectModal();
      setUiState('playing');
      render();
    });
  }
  if (reconnectPlayBtn) {
    bindOnce(reconnectPlayBtn, 'click', async () => {
      const chips = getRequestedChips();
      if (reconnectContext === 'startup') {
        const info = reconnectInfo || loadReconnectInfo();
        if (!info || !info.roomCode) return;
        onlineState.displayName = nameInput ? nameInput.value.trim() : '';
        onlineState.joinMode = 'play';
        onlineState.requestedChips = chips;
        joinChoiceConfirmed = true;
        onlineState.joinConfirmed = true;
        autoEnterOnStateSync = true;
        hideReconnectModal();
        await joinRoom(info.role || 'player', info.roomCode);
        showSeatSelectModal();
        return;
      }
      applyJoinMode('play', chips);
      hideReconnectModal();
      setUiState('playing');
      render();
      showSeatSelectModal();
    });
  }
  if (reconnectCancelBtn) {
    bindOnce(reconnectCancelBtn, 'click', () => {
      hideReconnectModal();
    });
  }

  const readyBtn = document.getElementById('ready-toggle-btn');
  if (readyBtn) {
    readyBtn.addEventListener('click', () => {
      if (onlineState.role === 'host') return;
      if (onlineState.joinMode === 'watch') return;
      if (!onlineState.seat) {
        const seatHelp = document.getElementById('seat-help-text');
        if (seatHelp) seatHelp.textContent = 'ÂÖà„Å´Â∏≠„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ';
        return;
      }
      onlineState.ready = !onlineState.ready;
      readyBtn.classList.toggle('on', onlineState.ready);
      readyBtn.textContent = onlineState.ready ? 'READY' : 'WAIT';
      updatePresence({ ready: onlineState.ready });
      updateParticipantList();
    });
  }

  // Fold confirm dialog handlers
  const foldCancelBtn = document.getElementById('fold-cancel-btn');
  const foldConfirmBtn = document.getElementById('fold-confirm-btn');
  if (foldCancelBtn) {
    bindOnce(foldCancelBtn, 'click', () => {
      hideFoldConfirm();
    });
  }
  if (foldConfirmBtn) {
    bindOnce(foldConfirmBtn, 'click', () => {
      hideFoldConfirm();
      doAction('fold');
    });
  }

  // Disconnect dialog handlers
  const disconnectWaitBtn = document.getElementById('disconnect-wait-btn');
  const disconnectExitBtn = document.getElementById('disconnect-exit-btn');
  if (disconnectWaitBtn) {
    bindOnce(disconnectWaitBtn, 'click', () => {
      hideDisconnectDialog();
    });
  }
  if (disconnectExitBtn) {
    bindOnce(disconnectExitBtn, 'click', () => {
      hideDisconnectDialog();
      leaveRoom({ clearReconnect: true });
    });
  }

  if (debugEnabled) {
    initDebugPanel();
    bindOnce(document, 'click', (e) => {
      const x = e.clientX;
      const y = e.clientY;
      const hit = document.elementFromPoint(x, y);
      debugLog(`click @${x},${y} -> ${hit?.id || hit?.className || hit?.tagName}`);
    }, { passive: true });
    bindOnce(document, 'touchstart', (e) => {
      const t = e.touches[0];
      if (!t) return;
      const hit = document.elementFromPoint(t.clientX, t.clientY);
      debugLog(`touch @${t.clientX},${t.clientY} -> ${hit?.id || hit?.className || hit?.tagName}`);
    }, { passive: true });
  }

  maybeShowReconnectPrompt();
});

function resetToSetup() {
  document.getElementById('showdown-overlay').classList.remove('visible');
  document.getElementById('next-hand-overlay').classList.remove('visible');
  document.getElementById('fold-confirm-overlay').classList.remove('visible');
  document.getElementById('tournament-bar').style.display = 'none';
  stopTournamentTimer();
  stopActionTimer();
  gameState = null;
  if (onlineState.role !== 'local') {
    leaveRoom({ clearReconnect: true });
  } else {
    setUiState('room');
  }
}

// ‚îÄ‚îÄ‚îÄ SERVICE WORKER & UPDATE NOTIFICATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').then(registration => {
      console.log('SW registered:', registration.scope);

      // Check for updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            // New version available
            showUpdateNotification();
          }
        });
      });
    }).catch(err => console.log('SW registration failed:', err));
  });
}

function showUpdateNotification() {
  const banner = document.createElement('div');
  banner.id = 'update-banner';
  banner.innerHTML = `
    <span>Êñ∞„Åó„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„ÅåÂà©Áî®ÂèØËÉΩ„Åß„Åô</span>
    <button onclick="location.reload()">Êõ¥Êñ∞</button>
  `;
  banner.style.cssText = `
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    background: var(--gold); color: #0f1a16; padding: 12px 20px;
    border-radius: 8px; font-family: inherit; font-size: 14px;
    display: flex; align-items: center; gap: 12px; z-index: 9999;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  `;
  banner.querySelector('button').style.cssText = `
    background: #0f1a16; color: var(--gold); border: none;
    padding: 6px 12px; border-radius: 4px; cursor: pointer; font-weight: 600;
  `;
  document.body.appendChild(banner);
}
</script>

<!-- Global Menu (outside screens for z-index) -->
<div id="header-menu" style="display:none; position:fixed; top:60px; right:20px; background:rgba(26,51,40,0.98); border:3px solid #d4af37; border-radius:12px; padding:12px; z-index:999999; min-width:200px; flex-direction:column; gap:8px; box-shadow: 0 10px 40px rgba(0,0,0,0.8);">
  <button class="header-menu-item" id="menu-join-btn" style="padding:12px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:8px; color:#f0ece0; cursor:pointer; display:none;">Ë¶≥Êà¶„Åã„ÇâÂèÇÂä†„Å∏</button>
  <button class="header-menu-item" id="menu-join-status" style="padding:12px; background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.15); border-radius:8px; color:#f0ece0; cursor:default; display:none;" disabled>ÂèÇÂä†Áä∂ÊÖã: Ë¶≥Êà¶</button>
  <button class="header-menu-item" id="menu-sound-toggle" style="padding:12px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:8px; color:#f0ece0; cursor:pointer;">Èü≥Èáè: ON</button>
  <button class="header-menu-item" id="menu-display-toggle" style="padding:12px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:8px; color:#f0ece0; cursor:pointer;">Ë°®Ë®òÂàáÊõø: CHIP</button>
  <button class="header-menu-item" id="menu-history-btn" style="padding:12px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:8px; color:#f0ece0; cursor:pointer;">Â±•Ê≠¥„ÇíË°®Á§∫</button>
  <button class="header-menu-item" id="menu-reset-btn" style="padding:12px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:8px; color:#f0ece0; cursor:pointer;">„Ç≤„Éº„É†ÁµÇ‰∫Ü„Åó„Å¶Êàª„Çã</button>
</div>
</body>
</html>
